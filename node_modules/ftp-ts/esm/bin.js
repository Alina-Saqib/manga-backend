import{URL as e}from"url";import t from"events";import*as s from"net";import{StringDecoder as r}from"string_decoder";import*as i from"tls";import o from"zlib";import{Writable as n}from"stream";import{createInterface as a}from"readline";function c(e){return this instanceof c?(this.v=e,this):new c(e)}function h(e,t,s){if(!Symbol.asyncIterator)throw new TypeError("Symbol.asyncIterator is not defined.");var r,i=s.apply(e,t||[]),o=[];return r={},n("next"),n("throw"),n("return"),r[Symbol.asyncIterator]=function(){return this},r;function n(e){i[e]&&(r[e]=t=>new Promise(((s,r)=>{o.push([e,t,s,r])>1||a(e,t)})))}function a(e,t){try{(s=i[e](t)).value instanceof c?Promise.resolve(s.value.v).then(h,d):l(o[0][2],s)}catch(e){l(o[0][3],e)}var s}function h(e){a("next",e)}function d(e){a("throw",e)}function l(e,t){e(t),o.shift(),o.length&&a(o[0][0],o[0][1])}}function d(e){if(!Symbol.asyncIterator)throw new TypeError("Symbol.asyncIterator is not defined.");var t,s=e[Symbol.asyncIterator];return s?s.call(e):(e=function(e){var t="function"==typeof Symbol&&Symbol.iterator,s=t&&e[t],r=0;if(s)return s.call(e);if(e&&"number"==typeof e.length)return{next(){return e&&r>=e.length&&(e=void 0),{value:e&&e[r++],done:!e}}};throw new TypeError(t?"Object is not iterable.":"Symbol.iterator is not defined.")}(e),t={},r("next"),r("throw"),r("return"),t[Symbol.asyncIterator]=function(){return this},t);function r(s){t[s]=e[s]&&(t=>new Promise(((r,i)=>{((e,t,s,r)=>{Promise.resolve(r).then((t=>{e({value:t,done:s})}),t)})(r,i,(t=e[s](t)).done,t.value)})))}}const l=/^total/,u=/(?:^|\r?\n)(\d{3}) [^\r\n]*\r?\n/,p=/\r?\n/g,f=/-/g,w=new Map([["jan",1],["feb",2],["mar",3],["apr",4],["may",5],["jun",6],["jul",7],["aug",8],["sep",9],["oct",10],["nov",11],["dec",12]]);class Parser extends n{constructor(e){super(),this._buffer="",this._debug=e.debug}static parseFeat(e){const t=e.split(p);t.shift(),t.pop();for(let e=0,s=t.length;e<s;++e)t[e]=t[e].trim();return t}async _write(e,t,s){const r=this._debug;let i;for(r&&r("[parser] write()"),this._buffer+=e.toString("binary"),r&&r("[parser] buffer: "+this._buffer);i=u.exec(this._buffer);){const e=this._buffer.substring(i.index+i[0].length);e.length&&(this._buffer=this._buffer.substring(0,i.index+i[0].length)),r&&r("[parser] < "+this._buffer);const t=parseInt(i[1],10);let s="(^|\\r?\\n)";s+=i[1],s+="(?: |\\-)";const o=new RegExp(s,"g"),n=this._buffer.replace(o,"$1").trim();this._buffer=e,r&&r("[parser] Response: code="+t+", buffer="+n),await this.emit("response",t,n)}s()}}const m=/^([-ld])((?:[-r][-w][-xstT]){3})(\+)?\s+(\d+)\s+(\S+)\s+(\S+)\s+(\d+)\s+(?:(?:(\w{3})\s+(\d{1,2})\s+(\d{1,2}):(\d{2}))|(?:(\w{3})\s+(\d{1,2})\s+(\d{4})))\s+(.+)$/,_=/^(\d{2})(?:-|\/)(\d{2})(?:-|\/)(\d{2,4})\s+(\d{2}):(\d{2})\s{0,1}([AaMmPp]{1,2})\s+(?:(\d+)|(<DIR>))\s+(.+)$/;function g(e){return(4&e?"r":"-")+(2&e?"w":"-")+(1&e?"x":"-")}function y(e){const t=(e=>{const t={name:""};for(;e&&!e.startsWith(" ");){const s=e.indexOf("=");if(-1==s)return"unexpected entry fact, no equals";const r=e.indexOf(";",s);if(-1==r)return"unexpected entry fact, no semicolon";t[e.substring(0,s).toLowerCase().replace(/-./g,(e=>e.substring(1).toUpperCase())).replace(/^.*?\./,(e=>e.toUpperCase()))]=e.substring(s+1,r),e=e.substring(r+1)}return e&&e.startsWith(" ")?(t.name=e.substring(1),t):"unexpected entry char, expected space followed by filename"})(e);if("string"==typeof t)return e;const s={acl:void 0,date:void 0,group:t["UNIX.groupname"]||t["UNIX.group"],name:t.name,owner:t["UNIX.ownername"]||t["UNIX.owner"],rights:void 0,size:t.size?parseInt(t.size,10):-1,sticky:!1,target:void 0,type:"dir"==t.type||"cdir"==t.type||"pdir"==t.type?"d":"-"};if(t.modify){const e=/^(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})(\.\d+)?$/.exec(t.modify);if(e){let t=0;if(e[7]){const s=parseInt(e[7].substring(1)),r=4-e[7].length;t=0==r?s:r>0?s*Math.pow(10,r):s/Math.pow(10,-r)}s.date=new Date(Date.UTC(parseInt(e[1]),parseInt(e[2])-1,parseInt(e[3]),parseInt(e[4]),parseInt(e[5]),parseInt(e[6]),t))}}if(t["UNIX.mode"]&&4==t["UNIX.mode"].length){const e=parseInt(t["UNIX.mode"],8);s.rights={user:g(e>>6),group:g(e>>3),other:g(e)}}else if(t.perm){let e=0;for(let s=0;s<t.perm.length;s++)switch(t.perm[s]){case"a":case"c":case"m":case"p":case"w":e|=2;break;case"r":e|=4;break;case"e":case"l":e|=1}s.rights={user:g(e),group:"---",other:"---"}}return Object.assign(s,{mlsx:t})}function v(e){let t;if(t=(e=>{const t=e.match(m);return t?{acl:t[3],date1:t[9],date2:t[13],group:t[6],hour:t[10],inodes:t[4],minute:t[11],month1:t[8],month2:t[12],name:t[15],owner:t[5],permission:t[2],size:t[7],type:t[1],year:t[14]}:null})(e)){let e,s;if("l"===t.type){const r=t.name.indexOf(" -> ");e=t.name.substring(0,r),s=t.name.substring(r+4)}else e=t.name;const r={acl:"+"===t.acl,date:void 0,group:t.group,name:e,owner:t.owner,rights:{group:t.permission.substring(3,6).replace(f,""),other:t.permission.substring(6,9).replace(f,""),user:t.permission.substring(0,3).replace(f,"")},size:parseInt(t.size,10),sticky:!1,target:s,type:t.type},i=r.rights&&r.rights.other.slice(-1);if(r.rights&&("t"===i?(r.rights.other=r.rights.other.slice(0,-1)+"x",r.sticky=!0):"T"===i&&(r.rights.other=r.rights.other.slice(0,-1),r.sticky=!0)),void 0!==t.month1&&void 0!==t.date1&&void 0!==t.hour&&void 0!==t.minute){const e=w.get(t.month1.toLowerCase()),s=parseInt(t.date1,10),i=(new Date).getFullYear(),o=parseInt(t.hour,10),n=parseInt(t.minute,10);let a=e.toString(),c=s.toString(),h=o.toString(),d=n.toString();e<10&&(a="0"+e),s<10&&(c="0"+s),o<10&&(h="0"+o),n<10&&(d="0"+n),r.date=new Date(i+"-"+a+"-"+c+"T"+h+":"+d),r.date.getTime()-Date.now()>1008e5&&(r.date=new Date(i-1+"-"+e+"-"+s+"T"+o+":"+n)),Date.now()-r.date.getTime()>160704e5&&(r.date=new Date(i+1+"-"+e+"-"+s+"T"+o+":"+n))}else if(void 0!==t.month2&&void 0!==t.date2&&void 0!==t.year){const e=w.get(t.month2.toLowerCase()),s=parseInt(t.date2,10),i=parseInt(t.year,10);let o=e.toString(),n=s.toString();e<10&&(o="0"+e),s<10&&(n="0"+s),r.date=new Date(i+"-"+o+"-"+n+"T00:00")}return r}if(t=(e=>{const t=e.match(_);return t?{ampm:t[6],date:t[2],hour:t[4],isdir:t[8],minute:t[5],month:t[1],name:t[9],size:t[7],year:t[3]}:null})(e)){const e=parseInt(t.month,10),s=parseInt(t.date,10);let r=parseInt(t.year,10),i=parseInt(t.hour,10);const o=parseInt(t.minute,10);return r+=r<70?2e3:1900,"p"===t.ampm[0].toLowerCase()&&i<12?i+=12:"a"===t.ampm[0].toLowerCase()&&12===i&&(i=0),{date:new Date(r,e-1,s,i,o),name:t.name,size:t.isdir?0:parseInt(t.size,10),type:t.isdir?"d":"-"}}return l.test(e)?null:e}const b=/(\d+),(\d+),(\d+),(\d+),([-\d]+),([-\d]+)/,S=/\((.)\1\1(\d+)\1\)/,T=/\r?\n/g,P=/"(.+)"(?: |$)/,E=/^([^ ]+)(?: |$)/,k=Buffer.from("NOOP\r\n");class FTP extends t{constructor(){super(...arguments),this.options={secure:!1},this.connected=!1,this._pasvReady=Promise.resolve(),this._queue=[],this._ending=!1,this._detectedSupport={},this._send=function(e,t){return h(this,arguments,(function*(){let s=null,r=null,i=null,o=null;if(this._keepalive&&(clearTimeout(this._keepalive),this._keepalive=void 0),void 0!==e){const n=(e,t,n)=>{e?o?o(e):r=e:i?i([n,t]):s=[n,t]};t?this._queue.unshift({cmd:e,cb:n}):this._queue.push({cmd:e,cb:n})}const n=this._queue.length;!this._curReq&&n&&this._socket&&this._socket.readable?(this._curReq=this._queue.shift(),"ABOR"===this._curReq.cmd&&this._pasvSocket&&(this._pasvSocket.aborting=!0),this._debug&&this._debug("[connection] > "+this._curReq.cmd),this._socket.write(this._curReq.cmd+"\r\n")):this._curReq||n||!this._ending||this._reset();let a=!1;for(;!a;){const e=new Promise(((e,t)=>{i=e,o=t,s?i(s):null!==r&&o(r)})),t=yield c(e);i=null,o=null,s=null,r=null,a=void 0===this._curReq,yield yield c(t)}}))}}static async connect(e={}){const t=new FTP;try{return await t.connect(e)}catch(e){throw t.logout().catch((e=>e)),e}}get feat(){return this._feat}connect(e={}){return new Promise(((t,r)=>{let o=!0;this.connected=!1,this.options.host=e.host||"localhost",this.options.port=e.port||21,this.options.user=e.user||"anonymous",this.options.password=e.password||""===e.password?e.password:"anonymous@",this.options.secure=e.secure||!1,this.options.secureOptions=e.secureOptions,this.options.connTimeout=e.connTimeout||1e4,this.options.dataTimeout=e.dataTimeout||e.pasvTimeout||1e4,this.options.aliveTimeout=e.keepalive||1e4,this.options.portAddress=e.portAddress,this.options.portRange=e.portRange,this.options.overrideFeats=e.overrideFeats,"function"==typeof e.debug&&(this._debug=e.debug);const n={},a=this._debug;let c=new s.Socket;if(c.setTimeout(0),c.setKeepAlive(!0),this._parser=new Parser({debug:a}),this._parser.on("response",((e,t)=>{const s=e/100|0;if(4===s||5===s)if(this._curReq){const s=this._curReq;this._curReq=void 0,s.cb(I(e,t),void 0,e),A(this._send())}else{const s=I(e,t);this.emit("error",s),o&&(r(s),o=!1)}else if(this._curReq){const r=this._curReq;1!==s?(this._curReq=void 0,r.cb(void 0,t,e),A(this._send())):r.cb(void 0,t,e)}h.cb()})),this.options.secure){n.host=this.options.host;const e=this.options.secureOptions;e&&Object.assign(n,e),n.socket=c,this.options.secureOptions=n}const h={cb:()=>{this._keepalive&&clearTimeout(this._keepalive),this._keepalive=setTimeout(d,this.options.aliveTimeout)},cmd:"NOOP"},d=()=>{this._socket&&this._socket.writable?this._curReq||0!==this._queue.length?h.cb():(this._curReq=h,a&&a("[connection] > NOOP"),this._socket.write(k)):this._keepalive&&(clearTimeout(this._keepalive),this._keepalive=void 0)},l=()=>{let e;clearTimeout(m),this._keepalive&&(clearTimeout(this._keepalive),this._keepalive=void 0),this.connected=!0,this._socket=c;const t=([s,r])=>{if("AUTH TLS"===e&&234!==s&&!0!==this.options.secure||"AUTH SSL"===e&&334!==s||"PBSZ"===e&&200!==s||"PROT"===e&&200!==s){const e=new ErrorWithCode(s,"Unable to secure connection(s)");throw this.emit("error",e),this._socket&&this._socket.end(),e}if(e){if("USER"===e){if(230!==s){if(!this.options.password&&""!==this.options.password){const e=I(s,"Password required");throw this.emit("error",e),this._socket&&this._socket.end(),e}return e="PASS",A(this._send("PASS "+this.options.password,!0)).then(t)}return e="PASS",t([s,r])}if("PASS"===e)return e="FEAT",A(this._send(e,!0)).then((e=>(e[1]&&(this._feat=Parser.parseFeat(e[1])),e)),(e=>{if(500!==e.code)throw e;return[e.code,e.message]})).then((e=>{this._feat||(this._feat=[]);const t=this.options.overrideFeats;if(t)for(const e of Object.keys(t)){const s=t[e];if("boolean"!=typeof s)if("string"!=typeof s);else{const t=this._feat.findIndex((t=>t==e||t.startsWith(e+" ")));if(-1==t){this._feat.push(e+" "+s);continue}this._feat[t]=e+" "+s}else{const t=this._feat.findIndex((t=>t==e||t.startsWith(e+" ")));if(-1==t&&s){this._feat.push(e);continue}if(-1!=t&&!s){this._feat.splice(t,1);continue}}}return e})).then(t);if("FEAT"===e)return e="TYPE",A(this._send("TYPE I",!0)).then(t);if("TYPE"===e)return this.emit("ready"),o=!1,this;if("PBSZ"===e)return e="PROT",A(this._send("PROT P",!0)).then(t);if("PROT"===e)return e="USER",A(this._send("USER "+this.options.user,!0)).then(t);if("AUTH"===e.substring(0,4))return"AUTH TLS"===e&&234!==s?(e="AUTH SSL",A(this._send(e,!0)).then(t)):("AUTH TLS"===e?this._secstate="upgraded-tls":"AUTH SSL"===e&&(this._secstate="upgraded-ssl"),c.removeAllListeners("data"),c.removeAllListeners("error"),this._curReq=void 0,n.socket=this._socket,n.session=void 0,new Promise((e=>{c=i.connect(n,(()=>e(l()))),c.setEncoding("binary"),c.on("data",u),c.once("end",f),c.on("error",p)})));throw new Error("No matched command: "+JSON.stringify(e))}return this.emit("greeting",r),this.options.secure&&"implicit"!==this.options.secure?(e="AUTH TLS",A(this._send(e,!0)).then(t)):(e="USER",A(this._send("USER "+this.options.user,!0)).then(t))},s=e=>{throw c.destroyed&&c.end(),e};if(this._secstate)return"upgraded-tls"===this._secstate&&!0===this.options.secure?(e="PBSZ",A(this._send("PBSZ 0",!0)).then(t).catch(s)):(e="USER",A(this._send("USER "+this.options.user,!0)).then(t).catch(s));{let e,r=null,i=null,o=null;const n=new Promise(((t,s)=>{r=t,i=s,o?t(o):void 0!==e&&s(e)}));return this._curReq={cb(s,n,a){s?i?i(s):e=s:r?r(t([a,n])):o=t([a,n])},cmd:""},n.catch(s)}};"implicit"===this.options.secure?this._socket=i.connect(n,(()=>l().then(t,r))):(c.once("connect",(()=>l().then(t,r))),this._socket=c);const u=e=>{a&&a("[connection] < "+e.toString("binary")),this._parser.write(e)};c.on("data",u);const p=e=>{clearTimeout(m),this._keepalive&&(clearTimeout(this._keepalive),this._keepalive=void 0),o?(r(e),o=!1,this._socket&&!this._socket.destroyed&&this._socket.end()):this.listenerCount("error")&&this.emit("error",e)};c.on("error",p);const f=()=>{w||(w=!0,clearTimeout(m),this._reset()),this.emit("end"),o&&(r("End before ready"),o=!1)};c.once("end",f),c.once("close",(e=>{w||(w=!0,clearTimeout(m),this._reset()),this.emit("close",e),o&&(r("Close before ready"),o=!1)}));let w=!1;const m=setTimeout((()=>{!this.listenerCount("error")&&o||this.emit("error",new Error("Timeout while connecting to server")),this._socket&&this._socket.destroy(),this._reset(),o&&(r(new Error("Timeout while connecting to server")),o=!1)}),this.options.connTimeout);try{this._socket.connect(this.options.port,this.options.host)}catch(e){r(e)}}))}end(){this._queue.length||this._curReq?this._ending=!0:this._reset()}destroy(){this._reset()}ascii(){return A(this._send("TYPE A"))}binary(){return A(this._send("TYPE I"))}abort(e=!0){return A(this._send("ABOR",Boolean(e)))}cwd(e,t){return A(this._send("CWD "+e,t)).then((([e,t])=>{const s=t&&P.exec(t);return s?s[1]:void 0}))}delete(e){return A(this._send("DELE "+e))}site(e){return A(this._send("SITE "+e))}status(){return A(this._send("STAT")).then((([e,t])=>t))}rename(e,t){return A(this._send("RNFR "+e)).then((()=>A(this._send("RNTO "+t,!0))))}logout(){return A(this._send("QUIT"))}async listSafe(e,t){if("string"!=typeof e)return"boolean"==typeof e?this.list(e):this.list();{const s=await this.pwd();await this.cwd(e);try{return this.list(t||!1)}finally{s&&await this.cwd(s)}}}async fileInfo(e){const t=this._feat||[];let s;if(!1!==this._detectedSupport.mlst)for(const e of t){if(!e.startsWith("MLST "))continue;const t=e.substring(5).split(";");t.length&&!t[t.length-1]&&t.pop(),s=t;break}if(!s){const t=await this.list(e,!1);let s=null;if(1==t.length&&"string"!=typeof t[0])s=t[0];else for(const r of t)"string"==typeof r||"."!=r.name&&r.name!=e||s&&"."==s.name||(s=r);return s}const[r,i]=await O(A(this._send("MLST "+e,!1)));if(502==r)return this._detectedSupport.mlst=!1,this.fileInfo(e);const o=y(i||"");if("string"==typeof o)throw new Error(o);return o}async list(e,t){let s;const i=this._feat||[];let n;if(!1!==this._detectedSupport.mlst)for(const e of i){if(!e.startsWith("MLST "))continue;const t=e.substring(5).split(";");t.length&&!t[t.length-1]&&t.pop(),n=t;break}return"boolean"==typeof e&&(t=e,e=void 0),s=e&&n?"MLSD "+e:e?"LIST "+e:n?"MLSD":"LIST",this._pasv((async i=>{if(this._queue[0]&&"ABOR"===this._queue[0].cmd){const e=new Error("Aborted");throw e.code="aborted",e}let n,a=!1,c="";const h=new r("utf8");let l;t?(l=o.createInflate(),i.pipe(l)):l=i;const u=()=>{h&&(c+=h.end()),a=!0,S()};l.on("data",(e=>{c+="string"==typeof e?h.write(Buffer.from(e)):h.write(e)})),l.once("error",(e=>{i.aborting||(n=e)})),l.once("end",u),l.once("close",u);let p,f=null,w=null,m=null;const _=new Promise(((e,t)=>{f=e,w=t,m?e(m):void 0!==p&&t(p)}));let g=0;const b=async()=>{var t,r;const i=[];try{for(var o,n=d(this._send(s,!0));!(o=await n.next()).done;){const[e]=o.value;i.push(e),1==++g&&226===e&&(g=2)}}catch(e){t={error:e}}finally{try{o&&!o.done&&(r=n.return)&&await r.call(n)}finally{if(t)throw t.error}}if("string"==typeof e&&s.startsWith("MLSD ")&&501==i[i.length-1]){const t=await this.fileInfo(e);return{a:t?[t]:[]}}if(2===g)return S();throw new Error("Expected 2 replies for list, count: "+g+", codes: "+i.join(", "))},S=()=>{if(a&&2===g){if(g=3,n){const e=new Error("Unexpected data connection error: "+n);throw w?w(e):p=e,e}if(i.aborting){const e=new Error("Aborted");throw e.code="aborted",w?w(e):p=e,e}const e=c.split(T);this._debug&&this._debug("Listing entries: "+JSON.stringify(e)),e.pop();const t=[];if(s.startsWith("MLSD"))for(let s=0,r=e.length;s<r;++s){const r=y(e[s]);"string"!=typeof r?t.push(r):this._debug&&this._debug("Skipped entry listing: "+r+": "+JSON.stringify(e[s]))}else for(let s=0,r=e.length;s<r;++s){const r=v(e[s]);null!==r?t.push(r):this._debug&&this._debug("Skipped entry listing: "+JSON.stringify(e[s]))}const r={a:t};return f?f(r):m=r,Promise.resolve(r)}return _};if(!t)return b();await A(this._send("MODE Z",!0));try{return await b()}finally{await A(this._send("MODE S",!0))}})).then((e=>e.a))}get(e,t){return this._pasv((async s=>{if(this._queue[0]&&"ABOR"===this._queue[0].cmd){const e=new Error("Aborted");throw e.code="aborted",e}let r,i=!1,n=!1,a=s;if(t){a=o.createInflate(),s.pipe(a);const e=s.emit;s.emit=(t,...i)=>"error"===t?(r||(r=new Error(i.join(", "))),!0):(i.unshift(t),e.apply(s,i),!0)}let c,h=null,d=null,l=!1;const u=new Promise(((e,t)=>{h=e,d=t,l?e():void 0!==c&&t(c)})),p=a.emit;a.emit=(e,...t)=>"error"===e?(r||(r=new Error(t.join(", "))),d?d(r):c=r||null,!0):"end"===e||"close"===e?(n||(n=!0),h?h():l=!0,!0):(t.unshift(e),this._debug&&this._debug("Get source emit: "+JSON.stringify(t)),p.apply(a,t),!0),s.pause();const f=()=>new Promise((async(t,s)=>{try{t([A(await(async()=>{const t=this._send("RETR "+e,!0);for(;;){const e=await t.next();if(e.done)throw new Error("Expexted result RETR");const[s]=e.value;if(this._debug&&this._debug("Get code: "+s),150===s||125===s)return i=!0,t}})()).then((()=>u)),a])}catch(e){s(e)}}));if(t){await A(this._send("MODE Z",!0));try{return await f()}finally{await A(this._send("MODE S",!0));const e=()=>{n?(p.call(a,"end"),p.call(a,"close")):i&&(p.call(a,"error",r),p.call(a,"close",!0))};u.then(e,e)}}else try{return await f()}finally{const e=()=>{n?(p.call(a,"end"),p.call(a,"close")):i&&(p.call(a,"error",r),p.call(a,"close",!0))};u.then(e,e)}}))}put(e,t,s){return this._store("STOR "+t,e,s||!1)}append(e,t,s){return this._store("APPE "+t,e,s||!1)}async pwd(){if(!1!==this._detectedSupport.pwd){const[e,t]=await O(A(this._send("PWD")));if(502!=e)return t&&(P.exec(t)||[])[1]}return this._detectedSupport.pwd=!1,this.cwd(".",!0)}async cdup(){if(!1!==this._detectedSupport.cdup){const[e]=await O(A(this._send("CDUP")));if(502!=e)return}return this._detectedSupport.cdup=!1,this.cwd("..",!0)}async mkdir(e,t){if(!t)return void await A(this._send("MKD "+e));const s=await this.pwd(),r="/"===e[0],i=s;r&&(e=e.substring(1)),"/"===e[e.length-1]&&(e=e.substring(0,e.length-1));const o=e.split("/"),n=o.length,a=async()=>{var e,t;let s=-1,r=!0;if(++s!==n){if(!r)return await A(this._send("MKD "+o[s],!0)),await A(this._send("CWD "+o[s],!0)),a();try{for(var i,c=d(this._send("CWD "+o[s],!0));!(i=await c.next()).done;){const[e]=i.value;return 550===e&&(r=!1,--s),a()}}catch(t){e={error:t}}finally{try{i&&!i.done&&(t=c.return)&&await t.call(c)}finally{if(e)throw e.error}}}};try{r?(await A(this._send("CWD /",!0)),await a()):await a()}finally{await A(this._send("CWD "+i,!0))}}rmdir(e,t){return t?this.list(e).then((async t=>{for(const s of t){if("string"==typeof s)throw new Error("Cannot remove when listing is string");let t=null;if(t="/"===s.name[0]?s.name:"/"===e[e.length-1]?e+s.name:e+"/"+s.name,"d"===s.type){if("."===s.name||".."===s.name)continue;await this.rmdir(t,!0)}else await this.delete(t)}return A(this._send("RMD "+e))})):A(this._send("RMD "+e))}async system(){const e=(await A(this._send("SYST")))[1];return e&&(E.exec(e)||[])[1]||""}async size(e){let t,s=502;return!1!==this._detectedSupport.size&&([s,t]=await O(A(this._send("SIZE "+e)))),502===s?(this._detectedSupport.size=!1,this.fileInfo(e).then((t=>{if(!t)throw new Error("Unable to get info for path "+JSON.stringify(e));if("d"==t.type)throw new Error("Can not get the size of a directory");if(-1!=t.size)return t.size;throw new Error("File not found")}))):t?parseInt(t,10):-1}async lastMod(e){let t,s=502;if(!1!==this._detectedSupport.mdtm&&([s,t]=await O(A(this._send("MDTM "+e)))),502===s)return this._detectedSupport.mdtm=!1,this.fileInfo(e).then((t=>{if(t&&t.date)return t.date;throw new Error("No modification time available for file "+JSON.stringify(e))}));if(s>=400)throw Object.assign(new Error("Error for modification time ("+s+"): "+t),{code:s});const r=(e=>{const t=e&&e.match(R);if(t)return{date:t[3],hour:t[4],minute:t[5],month:t[2],second:t[6],year:t[1]}})(t);if(!r)throw new Error("Invalid date/time format from server");return new Date(r.year+"-"+r.month+"-"+r.date+"T"+r.hour+":"+r.minute+":"+r.second)}restart(e){return A(this._send("REST "+e))}localPort(e,t){const r=s.isIP(e);if(0==r)throw new Error("Invalid IP: "+e);return[e=4==r?"0.0.0.0":"::",t||"5000-8000"]}async _pasv(e){let t,r,i=!0;const o=()=>{var e,t;const s=this._feat||[];return 0!=s.length&&!s.includes("EPSV")&&[void 0,"IPv4"].includes(null===(e=this._socket)||void 0===e?void 0:e.remoteFamily)||!1===this._detectedSupport.epsv?(0==s.length||s.includes("PASV"))&&!1!==this._detectedSupport.pasv&&[void 0,"IPv4"].includes(null===(t=this._socket)||void 0===t?void 0:t.remoteFamily)?"PASV":"":"EPSV"};let n="";const a=async([e,s])=>{if(this._curReq=void 0,!i||n&&"PASV"!=n){if(i){const e=s&&S.exec(s);if(!e)throw new Error("Unable to parse EPSV server response");t=this._socket.remoteAddress,r=parseInt(e[2],10),i=!1}}else{const e=s&&b.exec(s);if(!e)throw new Error("Unable to parse PASV server response");t=e[1],t+=".",t+=e[2],t+=".",t+=e[3],t+=".",t+=e[4],r=parseInt(e[5],10)<<8|parseInt(e[6],10),i=!1}const o=await this._pasvConnect(t,r).catch((e=>this._socket&&t!==this._socket.remoteAddress?(t=this._socket.remoteAddress,a([0,""])):A(this._send("ABOR",!0)).then((()=>{throw A(this._send()),e}))));return A(this._send()),o},c=async e=>{const t=await this._portConnect(e).catch((e=>A(this._send("ABOR",!0)).then((()=>{throw A(this._send()),e}))));return A(this._send()),t},h=async()=>{const t=this.options.portAddress;if(n=o(),n||!t)return A(this._send(n||"PASV")).then((async t=>{const s=await a(t),r=await e(s);return Array.isArray(r)?[r[0].then((()=>s.destroy()),(()=>s.destroy())),r[1]]:(s.destroy(),[Promise.resolve(),r])}),(e=>{if(500!=e.code&&502!=e.code||!n||("PASV"==n?this._detectedSupport.pasv=!1:"EPSV"==n&&(this._detectedSupport.epsv=!1)),!t&&!n)throw e;return h()}));{const r=s.isIP(t);if(4!=r&&6!=r)throw new Error("Invalid `portAddress`, must be IPv4 or IPv6: "+JSON.stringify(t));const[i,o]=await this.localPort(t,this.options.portRange),n=s.isIP(i);if(4!=n&&6!=n)throw new Error("Invalid `bindIp`, must be IPv4 or IPv6: "+JSON.stringify(i));if(!(4==n||this._feat&&this._feat.includes("EPRT")&&!1!==this._detectedSupport.eprt))throw new Error("Only IPv4 may be used for `bindIp` when connecting to servers without `EPRT` support");const a=await((e,t)=>new Promise(((r,i)=>{if(e){const o=s.createServer();let[n,a]="string"==typeof e?e.split("-",2).map((e=>e?parseInt(e,10):0)):[e,e];n||(n=1),(!a||a>65535)&&(a=65535),o.maxConnections=1;const c=()=>{n<a?(n++,o.listen(n,t)):i(new Error("Unable to find available port"))};o.on("error",c),o.on("listening",(()=>{o.removeListener("error",c),r(o)})),o.listen(n,t)}else i(new Error("Invalid `portRange`"))})))(o||"5000-8000",i),h=c(a),d=a.address(),l="string"!=typeof d?d.port:0;let u;if(4==n){const e=l>>8,s=255&l;u="PORT "+t.replace(/\./g,",")+","+e+","+s}else u="EPRT |2|"+t+"|"+l+"|";await A(this._send(u));const p=await h,f=await e(p).catch((e=>{throw e}));return Array.isArray(f)?[f[0].then((()=>p.destroy()),(()=>p.destroy())),f[1]]:(p.destroy(),[Promise.resolve(),f])}},d=this._pasvReady.then(h);return this._pasvReady=d.then((e=>e[0]),(()=>{})),d.then((e=>e[1]))}_portConnect(e){return new Promise(((t,s)=>{let r=null,i=!1;const o=setTimeout((()=>{i=!0,e.close(),s(new Error("Timed out while making data connection"))}),this.options.dataTimeout);e.on("connection",(n=>{this._pasvSocket=n,clearTimeout(o),this._debug&&this._debug("[connection] PORT socket connected"),n.once("error",(e=>{r=e,s(r)})),n.once("close",(()=>{if(!this._pasvSocket&&!i){let e="Unable to make data connection";r&&(e+="( "+r+")",r=null),s(new Error(e))}this._pasvSocket=void 0,e.close()})),t(n)})),e.on("error",s),e.on("close",(()=>{if(!this._pasvSocket&&!i){let e="Unable to make data connection";r&&(e+="( "+r+")",r=null),s(new Error(e))}this._pasvSocket=void 0}))}))}_pasvConnect(e,t){return new Promise(((r,o)=>{let n=new s.Socket,a=null,c=!1;const h=setTimeout((()=>{c=!0,n.destroy(),o(new Error("Timed out while making data connection"))}),this.options.dataTimeout);n.setTimeout(0),n.once("connect",(()=>{this._debug&&this._debug("[connection] PASV socket connected"),!0===this.options.secure&&(this.options.secureOptions=this.options.secureOptions||{},this.options.secureOptions.socket=n,this.options.secureOptions.session=this._socket.getSession(),n=i.connect(this.options.secureOptions),n.setTimeout(0)),clearTimeout(h),this._pasvSocket=n,r(n)})),n.once("error",(e=>{a=e,o(a)})),n.once("end",(()=>{clearTimeout(h)})),n.once("close",(()=>{if(clearTimeout(h),!this._pasvSocket&&!c){let e="Unable to make data connection";a&&(e+="( "+a+")",a=null),o(new Error(e))}this._pasvSocket=void 0})),n.connect(t,e)}))}_store(e,t,s){return Buffer.isBuffer(t)||"string"==typeof t||void 0===t.pause||t.pause(),this._pasv((async r=>{if(this._queue[0]&&"ABOR"===this._queue[0].cmd){const e=new Error("Aborted");throw e.code="aborted",e}let i=null;r.once("error",(e=>{i=e}));const n=async s=>{var r,i;try{for(var o,n=d(this._send(e,!0));!(o=await n.next()).done;){const[e]=o.value;150!==e&&125!==e||(Buffer.isBuffer(t)?(s.write(t),s.end()):"string"==typeof t?await import("fs").then((e=>{e.stat(t,(r=>{r?s.end():e.createReadStream(t).pipe(s)}))})):(t.pipe(s),t.resume()))}}catch(e){r={error:e}}finally{try{o&&!o.done&&(i=n.return)&&await i.call(n)}finally{if(r)throw r.error}}};try{if(!s)return n(r);{await A(this._send("MODE Z",!0));const e=o.createDeflate({level:8});try{return e.pipe(r),n(e)}finally{e.end(),await A(this._send("MODE S",!0))}}}catch(e){throw e||i}}))}_reset(){this._pasvSock&&this._pasvSock.writable&&this._pasvSock.end(),this._socket&&this._socket.writable&&this._socket.end(),this._socket=void 0,this._pasvSock=void 0,this._feat=void 0,this._curReq=void 0,this._secstate=void 0,this._keepalive&&(clearTimeout(this._keepalive),this._keepalive=void 0),this._queue=[],this._ending=!1,this._parser=void 0,this.options.host=this.options.port=this.options.user=this.options.password=this.options.secure=this.options.connTimeout=this.options.dataTimeout=this.options.keepalive=this._debug=void 0,this.connected=!1}}class ErrorWithCode extends Error{constructor(e,t){super(t||""+e),this.code=e}}function I(e,t){return new ErrorWithCode(e,t)}const R=/^(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})(\d+)(?:.\d+)?$/;async function O(e){try{return await e}catch(e){if(e instanceof ErrorWithCode&&(500==e.code||502==e.code))return[502,e.message];throw e}}async function A(e){let t,s;do{t=await e.next(),t.done&&!t.value||(s=t.value)}while(!t.done);return s}const x=["list","get","put","append","exit","rename","delete","abort","cwd","status"],U=Symbol("Mute"),D=((q=process.stdout)[U]=!1,new Proxy(q,{get:(e,t)=>"mute"===t?e[U]:"_write"===t?(t,s,r)=>{const i=e[U];!1===i?e._write(t,s,r):!0===i||""===i||"object"==typeof t&&!Buffer.isBuffer(t)?r&&r():e._write(i.repeat(t.length),s||"uft8",r)}:e[t],set:(e,t,s)=>"mute"===t?(e[U]=s,!0):(e[t]=s,!0),has:(e,t)=>"mute"===t||Object.prototype.hasOwnProperty.call(e,t)}));var q;const C=a({completer(e,t){if(N.state){const s=x.filter((t=>t.startsWith(e)));t(null,[s.length?s:x,e])}else t(null,[[],e])},input:process.stdin,output:D,prompt:"ftps-ts> "}),L=process.argv.slice(2),N={debug:!1,enteredPassword:void 0,secure:void 0,state:0,portAddress:void 0,portRange:void 0};function M(e){e("Usage:    ftp-ts [--verbose] [--implicit | --explicit | --secure-control] [--port-addr=PORT_ADDR] [--port-range=PORT_RANGE] [--password] <CONNECTION> [+FEAT0, +FEAT1..] [.FEAT0, .FEAT1..]"),e(""),e("Flags:"),e("  -v --verbose         Print verbose protocol information."),e("     --explicit        The control connection is upgraded to SSL/TLS, the data channel is also encrypted."),e("     --implicit        The control connection is established using SSL/TLS, the data channel is not encrypted."),e("     --secure-control  Like `explicit` for the control channel, except the data channel is not encrypted."),e("     --port-addr=PA    The IP to use for PORT commands."),e("     --port-range=PR   The range of port numbers to choose from for PORT commands. Default: `5000-8000`."),e("  -p --password        Enter the password into the CLI prompt."),e(""),e("CONNECTION:"),e("  The URI to connect to."),e("  If the protocol is `ftps` the `explicit` mode will be used if no other has been specified."),e("  "),e("  Example: `ftps://localhost` for an anonymous login over TLS."),e("  Example: `ftp://localhost` for an anonymous login without encryption."),e("  Example: `ftps://usera@localhost` for a user login (combine with `-p` for password)."),e("  Example: `ftps://usera:passa@localhost` for a password login (not recommended, use `-p`).")}function F(){N.state=1,L[0]||(console.error("No connection string given."),console.error(),M(console.error),process.exit(1));const t=new e(L[0]);L.splice(0,1);const s={host:t.hostname,password:void 0===N.enteredPassword?t.password:N.enteredPassword,port:t.port?parseInt(t.port,10):void 0,secure:void 0===N.secure?"ftps:"===t.protocol:N.secure,user:t.username,portAddress:N.portAddress,portRange:N.portRange};if(N.debug&&(s.debug=e=>{console.log("ftp-ts: [VERBOSE] ",e)}),L.length){s.overrideFeats={};for(const e of L)e.startsWith("+")?s.overrideFeats[e.substring(1).toUpperCase()]=!0:e.startsWith(".")&&(s.overrideFeats[e.substring(1).toUpperCase()]=!1)}return FTP.connect(s).then((e=>new Promise((t=>{C.on("SIGINT",(async()=>{try{await e.logout()}catch(e){C.write(e)}process.stdin.pause(),t()})),C.on("line",(async s=>{const r=s.split(" "),i=r[0];if("list"===i)try{console.dir(await e.list())}catch(e){C.write(e)}else if("get"===i){const t=r[1];if(void 0!==t){const s=r[2]?"true"===r[2]:void 0;try{await e.get(t,s)}catch(e){C.write(e)}}else C.write("Path are need to do get.")}else if("put"===i){const t=r[1],s=r[2];if(void 0!==t&&void 0!==s){const i=r[2]?"true"===r[2]:void 0;try{await e.put(t,s,i)}catch(e){C.write(e)}}else C.write("Path to file and destination are needed.")}else if("append"===i){const t=r[1],s=r[2];if(void 0!==t&&void 0!==s){const i=r[2]?"true"===r[2]:void 0;try{await e.append(t,s,i)}catch(e){C.write(e)}}else C.write("Path to file and destination are needed.")}else if("rename"===i){const t=r[1],s=r[2];if(void 0!==t&&void 0!==s)try{await e.rename(t,s)}catch(e){C.write(e)}else C.write("Old and new path are needed.")}else if("logout"===i||"exit"===i){try{await e.logout()}catch(e){C.write(e)}process.stdin.pause(),C.close(),t()}else if("delete"===i){const t=r[1];if(t)try{await e.delete(t),C.write("Deleted "+t)}catch(e){C.write(e)}else C.write("Path needed to delete a file.")}else if("cwd"===i){const t=r[1];if(t)try{C.write(await e.cwd(t)||t)}catch(e){C.write(e)}else C.write("Path needed to change directory.")}else if("abort"===i)try{await e.abort(),C.write("Aborted.")}catch(e){C.write(e)}else if("site"===i)if(r.length>1)try{await e.site(r.slice(1).join(" "))}catch(e){C.write(e)}else C.write("The SITE command needs a command to run.");else if("status"===i)try{C.write(await e.status())}catch(e){C.write(e)}}))}))),(e=>{e.message&&console.error(e.message),console.error(e),process.stdin.pause(),C.close()}))}for(let e=0;e<L.length;e++){const t=L[e];"-v"===t||"--verbose"===t?(L.splice(e--,1),N.debug=!0):t.startsWith("--port-range=")?(L.splice(e--,1),N.portRange=t.substring(13)):t.startsWith("--port-addr=")?(L.splice(e--,1),N.portAddress=t.substring(12)):"--implicit"===t?(L.splice(e--,1),N.secure="implicit"):"--secure-control"===t?(L.splice(e--,1),N.secure="control"):"--explicit"===t?(L.splice(e--,1),N.secure=!0):"--help"===t?(L.splice(e--,1),M(console.log),process.exit(0)):t&&"-"===t[0]&&"-p"!==t&&"--password"!==t&&(L.splice(e--,1),console.warn("Unrecognized argument: "+JSON.stringify(t)))}"-p"===L[0]||"--password"===L[0]?(L.splice(0,1),C.question("Password: ",(e=>{D.mute=!1,N.enteredPassword=e,D.write("\r\n"),F()})),D.mute="*"):F();
//# sourceMappingURL=bin.js.map
