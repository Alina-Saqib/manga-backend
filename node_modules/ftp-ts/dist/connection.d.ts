/// <reference types="node" />
import EventEmitter from "events";
import * as tls from "tls";
export interface IOptions {
    /**
     * The hostname or IP address of the FTP server. Default: 'localhost'
     */
    host: string;
    /**
     * The port of the FTP server. Default: 21
     */
    port: number;
    /**
     * Set to true for both control and data connection encryption, 'control' for control connection encryption only, or 'implicit' for
     * implicitly encrypted control connection (this mode is deprecated in modern times, but usually uses port 990) Default: false
     */
    secure: string | boolean;
    /**
     * Additional options to be passed to tls.connect(). Default: (none)
     */
    secureOptions?: tls.ConnectionOptions;
    /**
     * Username for authentication. Default: 'anonymous'
     */
    user: string;
    /**
     * Password for authentication. Default: 'anonymous@'
     */
    password: string;
    /**
     * How long (in milliseconds) to wait for the control connection to be established. Default: 10000
     */
    connTimeout: number;
    /**
     * How long (in milliseconds) to wait for a PASV data connection to be established. Default: 10000
     */
    pasvTimeout: number;
    /**
     * How long (in milliseconds) to wait for a PASV data connection to be established. Default: 10000
     */
    dataTimeout: number;
    /**
     * How often (in milliseconds) to send a 'dummy' (NOOP) command to keep the connection alive. Default: 10000
     */
    keepalive?: number;
    aliveTimeout: number;
    debug?: (arg: string) => any;
    portAddress?: string;
    portRange?: string;
    overrideFeats?: {
        AUTH?: false | string;
        EPRT?: boolean;
        EPSV?: boolean;
        MDTM?: boolean;
        MFMT?: boolean;
        MLST?: false | string;
        PASV?: boolean;
        SIZE?: boolean;
        UTF8?: boolean;
        [k: string]: boolean | string | undefined;
    };
}
/**
 * Element returned by Client#list()
 */
export interface IListingElement {
    acl?: boolean;
    /**
     * A single character denoting the entry type: 'd' for directory, '-' for file (or 'l' for symlink on **\*NIX only**).
     */
    type: string;
    /**
     * The name of the entry
     */
    name: string;
    /**
     * The size of the entry in bytes
     */
    size: number;
    /**
     * The last modified date of the entry
     */
    date?: Date;
    /**
     * The various permissions for this entry **(*NIX only)**
     */
    rights?: {
        /**
         * An empty string or any combination of 'r', 'w', 'x'.
         */
        user: string;
        /**
         * An empty string or any combination of 'r', 'w', 'x'.
         */
        group: string;
        /**
         * An empty string or any combination of 'r', 'w', 'x'.
         */
        other: string;
    };
    /**
     * The user name or ID that this entry belongs to **(*NIX only)**.
     */
    owner?: string;
    /**
     * The group name or ID that this entry belongs to **(*NIX only)**.
     */
    group?: string;
    /**
     * For symlink entries, this is the symlink's target **(*NIX only)**.
     */
    target?: string;
    /**
     * True if the sticky bit is set for this entry **(*NIX only)**.
     */
    sticky?: boolean;
}
export interface IRegDate {
    year?: string;
    month?: string;
    date?: string;
    hour?: string;
    minute?: string;
    second?: string;
}
export declare class FTP extends EventEmitter {
    /**
     * Static function that returns a promise to a newly connected instance.
     * @param options connect options
     * @returns a connected `FTP` instance
     */
    static connect(options?: Partial<IOptions>): Promise<FTP>;
    options: IOptions;
    connected: boolean;
    private _socket?;
    private _pasvSock?;
    private _pasvSocket?;
    private _pasvReady;
    private _feat?;
    private _curReq?;
    private _queue;
    private _secstate?;
    private _debug?;
    private _keepalive?;
    private _ending;
    private _parser?;
    private readonly _detectedSupport;
    /**
     * The features the most recently connected server supports.
     */
    get feat(): string[] | undefined;
    /**
     * Connects using the options given.
     * @param options connect options
     * @returns `this` after being connected
     */
    connect(options?: Partial<IOptions>): Promise<this>;
    end(): void;
    destroy(): void;
    /**
     * Sets the transfer data type to ASCII.
     */
    ascii(): Promise<void>;
    /**
     * Sets the transfer data type to binary (default at time of connection).
     */
    binary(): Promise<void>;
    /**
     * Aborts the current data transfer (e.g. from get(), put(), or list())
     */
    abort(immediate?: boolean): Promise<void>;
    /**
     * Changes the current working directory to path. callback has 2 parameters: < Error >err, < string >currentDir.
     * Note: currentDir is only given if the server replies with the path in the response text.
     */
    cwd(path: string, promote?: boolean): Promise<string | undefined>;
    /**
     * Delete a file on the server.
     */
    delete(path: string): Promise<void>;
    /**
     * Sends command (e.g. 'CHMOD 755 foo', 'QUOTA') using SITE.
     */
    site(command: string): Promise<[number, string | undefined]>;
    /**
     * Retrieves human-readable information about the server's status.
     */
    status(): Promise<string>;
    /**
     * Renames oldPath to newPath on the server
     */
    rename(oldPath: string, newPath: string): Promise<void>;
    /**
     * Logout the user from the server.
     */
    logout(): Promise<void>;
    /**
     * Optional "standard" commands (RFC 959)
     * Similar to list(), except the directory is temporarily changed to path to retrieve the directory listing.
     * This is useful for servers that do not handle characters like spaces and quotes in directory names well for the LIST command.
     * This function is "optional" because it relies on pwd() being available.
     */
    listSafe(path?: string, useCompression?: boolean): Promise<Array<IListingElement | string>>;
    listSafe(useCompression: boolean): Promise<Array<IListingElement | string>>;
    fileInfo(path: string): Promise<IListingElement | null>;
    /**
     * Retrieves the directory listing of path.
     * @param path defaults to the current working directory.
     * @param useCompression defaults to false.
     */
    list(path?: string, useCompression?: boolean): Promise<Array<IListingElement | string>>;
    list(useCompression: boolean): Promise<Array<IListingElement | string>>;
    /**
     * Retrieves a file at path from the server. useCompression defaults to false
     */
    get(path: string, useCompression?: boolean): Promise<NodeJS.ReadableStream>;
    /**
     * Sends data to the server to be stored as destPath.
     * @param input can be a ReadableStream, a Buffer, or a path to a local file.
     * @param destPath
     * @param useCompression defaults to false.
     */
    put(input: NodeJS.ReadableStream | Buffer | string, destPath: string, useCompression?: boolean): Promise<void>;
    /**
     * Same as put(), except if destPath already exists, it will be appended to instead of overwritten.
     * @param input can be a ReadableStream, a Buffer, or a path to a local file.
     * @param destPath
     * @param useCompression defaults to false.
     */
    append(input: NodeJS.ReadableStream | Buffer | string, destPath: string, useCompression?: boolean): Promise<void>;
    /**
     * Optional "standard" commands (RFC 959)
     * Retrieves the current working directory
     */
    pwd(): Promise<string | undefined>;
    /**
     * Optional "standard" commands (RFC 959)
     * Changes the working directory to the parent of the current directory
     */
    cdup(): Promise<void>;
    /**
     * Optional "standard" commands (RFC 959)
     * Creates a new directory, path, on the server. recursive is for enabling a 'mkdir -p' algorithm and defaults to false
     */
    mkdir(path: string, recursive?: boolean): Promise<void>;
    /**
     * Optional "standard" commands (RFC 959)
     * Removes a directory, path, on the server. If recursive, this call will delete the contents of the directory if it is not empty
     */
    rmdir(path: string, recursive?: boolean): Promise<void>;
    /**
     * Optional "standard" commands (RFC 959)
     * Retrieves the server's operating system.
     */
    system(): Promise<string>;
    /**
     * Extended commands (RFC 3659)
     * Retrieves the size of path
     */
    size(path: string): Promise<number>;
    /**
     * Retrieves the last modified date and time for `path`.
     *
     * Extensions to FTP (RFC 3659): https://datatracker.ietf.org/doc/html/rfc3659#section-3
     */
    lastMod(path: string): Promise<Date>;
    /**
     * Sets the file byte offset for the next file transfer action (get/put) to `byteOffset`.
     *
     * Extensions to FTP (RFC 3659): https://datatracker.ietf.org/doc/html/rfc3659#section-3
     */
    restart(byteOffset: number): Promise<void>;
    /**
     * This method may be overridden on the instance to allow for better managed `PORT`/`EPRT` commands.
     *
     * For example, you may wish to bind only to a specific network interface for security reasons.
     * In that case you may override this method to return the `bindIp` with a value of `127.0.0.1` instead of `0.0.0.0` to only allow incoming connections from localhost.
     *
     * Another reason may be to decide upon a port number and `await` some NAT rules to propagate before the remote server connects.
     *
     * This could also be useful if your external IP family does not match the family of your interface due to proxying or NAT rules.
     * By default the zero `bindIp` will always be in the same IP family as the external IP set as `portAddress` in the `IOption` object.
     *
     * @param bindIp the ip for the interface
     * @param portRange a suggested port range, usually provided from the configuration option
     * @returns an async tuple containing the (possibly changed) `bindIp` and a `portRange`/`portNumber`; unless overridden the `bindIp` is `0.0.0.0` or `::`
     */
    localPort(bindIp: string, portRange?: string): [string, string | number] | Promise<[string, string | number]>;
    private _pasv;
    private _portConnect;
    private _pasvConnect;
    private _store;
    private readonly _send;
    private _reset;
}
export declare class ErrorWithCode extends Error {
    readonly code: number;
    constructor(code: number, text: string);
}
export default FTP;
