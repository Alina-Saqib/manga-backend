import t from"events";import*as e from"net";import{StringDecoder as s}from"string_decoder";import*as i from"tls";import n from"zlib";import o,{parseMlsxEntry as r,parseListEntry as c}from"./parser.mjs";import"stream";function a(t){return this instanceof a?(this.v=t,this):new a(t)}function h(t,e,s){if(!Symbol.asyncIterator)throw new TypeError("Symbol.asyncIterator is not defined.");var i,n=s.apply(t,e||[]),o=[];return i={},r("next"),r("throw"),r("return"),i[Symbol.asyncIterator]=function(){return this},i;function r(t){n[t]&&(i[t]=e=>new Promise(((s,i)=>{o.push([t,e,s,i])>1||c(t,e)})))}function c(t,e){try{(s=n[t](e)).value instanceof a?Promise.resolve(s.value.v).then(h,d):u(o[0][2],s)}catch(t){u(o[0][3],t)}var s}function h(t){c("next",t)}function d(t){c("throw",t)}function u(t,e){t(e),o.shift(),o.length&&c(o[0][0],o[0][1])}}function d(t){if(!Symbol.asyncIterator)throw new TypeError("Symbol.asyncIterator is not defined.");var e,s=t[Symbol.asyncIterator];return s?s.call(t):(t=function(t){var e="function"==typeof Symbol&&Symbol.iterator,s=e&&t[e],i=0;if(s)return s.call(t);if(t&&"number"==typeof t.length)return{next(){return t&&i>=t.length&&(t=void 0),{value:t&&t[i++],done:!t}}};throw new TypeError(e?"Object is not iterable.":"Symbol.iterator is not defined.")}(t),e={},i("next"),i("throw"),i("return"),e[Symbol.asyncIterator]=function(){return this},e);function i(s){e[s]=t[s]&&(e=>new Promise(((i,n)=>{((t,e,s,i)=>{Promise.resolve(i).then((e=>{t({value:e,done:s})}),e)})(i,n,(e=t[s](e)).done,e.value)})))}}const u=/(\d+),(\d+),(\d+),(\d+),([-\d]+),([-\d]+)/,l=/\((.)\1\1(\d+)\1\)/,p=/\r?\n/g,f=/"(.+)"(?: |$)/,_=/^([^ ]+)(?: |$)/,w=Buffer.from("NOOP\r\n");class FTP extends t{constructor(){super(...arguments),this.options={secure:!1},this.connected=!1,this._pasvReady=Promise.resolve(),this._queue=[],this._ending=!1,this._detectedSupport={},this._send=function(t,e){return h(this,arguments,(function*(){let s=null,i=null,n=null,o=null;if(this._keepalive&&(clearTimeout(this._keepalive),this._keepalive=void 0),void 0!==t){const r=(t,e,r)=>{t?o?o(t):i=t:n?n([r,e]):s=[r,e]};e?this._queue.unshift({cmd:t,cb:r}):this._queue.push({cmd:t,cb:r})}const r=this._queue.length;!this._curReq&&r&&this._socket&&this._socket.readable?(this._curReq=this._queue.shift(),"ABOR"===this._curReq.cmd&&this._pasvSocket&&(this._pasvSocket.aborting=!0),this._debug&&this._debug("[connection] > "+this._curReq.cmd),this._socket.write(this._curReq.cmd+"\r\n")):this._curReq||r||!this._ending||this._reset();let c=!1;for(;!c;){const t=new Promise(((t,e)=>{n=t,o=e,s?n(s):null!==i&&o(i)})),e=yield a(t);n=null,o=null,s=null,i=null,c=void 0===this._curReq,yield yield a(e)}}))}}static async connect(t={}){const e=new FTP;try{return await e.connect(t)}catch(t){throw e.logout().catch((t=>t)),t}}get feat(){return this._feat}connect(t={}){return new Promise(((s,n)=>{let r=!0;this.connected=!1,this.options.host=t.host||"localhost",this.options.port=t.port||21,this.options.user=t.user||"anonymous",this.options.password=t.password||""===t.password?t.password:"anonymous@",this.options.secure=t.secure||!1,this.options.secureOptions=t.secureOptions,this.options.connTimeout=t.connTimeout||1e4,this.options.dataTimeout=t.dataTimeout||t.pasvTimeout||1e4,this.options.aliveTimeout=t.keepalive||1e4,this.options.portAddress=t.portAddress,this.options.portRange=t.portRange,this.options.overrideFeats=t.overrideFeats,"function"==typeof t.debug&&(this._debug=t.debug);const c={},a=this._debug;let h=new e.Socket;if(h.setTimeout(0),h.setKeepAlive(!0),this._parser=new o({debug:a}),this._parser.on("response",((t,e)=>{const s=t/100|0;if(4===s||5===s)if(this._curReq){const s=this._curReq;this._curReq=void 0,s.cb(m(t,e),void 0,t),S(this._send())}else{const s=m(t,e);this.emit("error",s),r&&(n(s),r=!1)}else if(this._curReq){const i=this._curReq;1!==s?(this._curReq=void 0,i.cb(void 0,e,t),S(this._send())):i.cb(void 0,e,t)}d.cb()})),this.options.secure){c.host=this.options.host;const t=this.options.secureOptions;t&&Object.assign(c,t),c.socket=h,this.options.secureOptions=c}const d={cb:()=>{this._keepalive&&clearTimeout(this._keepalive),this._keepalive=setTimeout(u,this.options.aliveTimeout)},cmd:"NOOP"},u=()=>{this._socket&&this._socket.writable?this._curReq||0!==this._queue.length?d.cb():(this._curReq=d,a&&a("[connection] > NOOP"),this._socket.write(w)):this._keepalive&&(clearTimeout(this._keepalive),this._keepalive=void 0)},l=()=>{let t;clearTimeout(y),this._keepalive&&(clearTimeout(this._keepalive),this._keepalive=void 0),this.connected=!0,this._socket=h;const e=([s,n])=>{if("AUTH TLS"===t&&234!==s&&!0!==this.options.secure||"AUTH SSL"===t&&334!==s||"PBSZ"===t&&200!==s||"PROT"===t&&200!==s){const t=new ErrorWithCode(s,"Unable to secure connection(s)");throw this.emit("error",t),this._socket&&this._socket.end(),t}if(t){if("USER"===t){if(230!==s){if(!this.options.password&&""!==this.options.password){const t=m(s,"Password required");throw this.emit("error",t),this._socket&&this._socket.end(),t}return t="PASS",S(this._send("PASS "+this.options.password,!0)).then(e)}return t="PASS",e([s,n])}if("PASS"===t)return t="FEAT",S(this._send(t,!0)).then((t=>(t[1]&&(this._feat=o.parseFeat(t[1])),t)),(t=>{if(500!==t.code)throw t;return[t.code,t.message]})).then((t=>{this._feat||(this._feat=[]);const e=this.options.overrideFeats;if(e)for(const t of Object.keys(e)){const s=e[t];if("boolean"!=typeof s)if("string"!=typeof s);else{const e=this._feat.findIndex((e=>e==t||e.startsWith(t+" ")));if(-1==e){this._feat.push(t+" "+s);continue}this._feat[e]=t+" "+s}else{const e=this._feat.findIndex((e=>e==t||e.startsWith(t+" ")));if(-1==e&&s){this._feat.push(t);continue}if(-1!=e&&!s){this._feat.splice(e,1);continue}}}return t})).then(e);if("FEAT"===t)return t="TYPE",S(this._send("TYPE I",!0)).then(e);if("TYPE"===t)return this.emit("ready"),r=!1,this;if("PBSZ"===t)return t="PROT",S(this._send("PROT P",!0)).then(e);if("PROT"===t)return t="USER",S(this._send("USER "+this.options.user,!0)).then(e);if("AUTH"===t.substring(0,4))return"AUTH TLS"===t&&234!==s?(t="AUTH SSL",S(this._send(t,!0)).then(e)):("AUTH TLS"===t?this._secstate="upgraded-tls":"AUTH SSL"===t&&(this._secstate="upgraded-ssl"),h.removeAllListeners("data"),h.removeAllListeners("error"),this._curReq=void 0,c.socket=this._socket,c.session=void 0,new Promise((t=>{h=i.connect(c,(()=>t(l()))),h.setEncoding("binary"),h.on("data",p),h.once("end",_),h.on("error",f)})));throw new Error("No matched command: "+JSON.stringify(t))}return this.emit("greeting",n),this.options.secure&&"implicit"!==this.options.secure?(t="AUTH TLS",S(this._send(t,!0)).then(e)):(t="USER",S(this._send("USER "+this.options.user,!0)).then(e))},s=t=>{throw h.destroyed&&h.end(),t};if(this._secstate)return"upgraded-tls"===this._secstate&&!0===this.options.secure?(t="PBSZ",S(this._send("PBSZ 0",!0)).then(e).catch(s)):(t="USER",S(this._send("USER "+this.options.user,!0)).then(e).catch(s));{let t,i=null,n=null,o=null;const r=new Promise(((e,s)=>{i=e,n=s,o?e(o):void 0!==t&&s(t)}));return this._curReq={cb(s,r,c){s?n?n(s):t=s:i?i(e([c,r])):o=e([c,r])},cmd:""},r.catch(s)}};"implicit"===this.options.secure?this._socket=i.connect(c,(()=>l().then(s,n))):(h.once("connect",(()=>l().then(s,n))),this._socket=h);const p=t=>{a&&a("[connection] < "+t.toString("binary")),this._parser.write(t)};h.on("data",p);const f=t=>{clearTimeout(y),this._keepalive&&(clearTimeout(this._keepalive),this._keepalive=void 0),r?(n(t),r=!1,this._socket&&!this._socket.destroyed&&this._socket.end()):this.listenerCount("error")&&this.emit("error",t)};h.on("error",f);const _=()=>{v||(v=!0,clearTimeout(y),this._reset()),this.emit("end"),r&&(n("End before ready"),r=!1)};h.once("end",_),h.once("close",(t=>{v||(v=!0,clearTimeout(y),this._reset()),this.emit("close",t),r&&(n("Close before ready"),r=!1)}));let v=!1;const y=setTimeout((()=>{!this.listenerCount("error")&&r||this.emit("error",new Error("Timeout while connecting to server")),this._socket&&this._socket.destroy(),this._reset(),r&&(n(new Error("Timeout while connecting to server")),r=!1)}),this.options.connTimeout);try{this._socket.connect(this.options.port,this.options.host)}catch(t){n(t)}}))}end(){this._queue.length||this._curReq?this._ending=!0:this._reset()}destroy(){this._reset()}ascii(){return S(this._send("TYPE A"))}binary(){return S(this._send("TYPE I"))}abort(t=!0){return S(this._send("ABOR",Boolean(t)))}cwd(t,e){return S(this._send("CWD "+t,e)).then((([t,e])=>{const s=e&&f.exec(e);return s?s[1]:void 0}))}delete(t){return S(this._send("DELE "+t))}site(t){return S(this._send("SITE "+t))}status(){return S(this._send("STAT")).then((([t,e])=>e))}rename(t,e){return S(this._send("RNFR "+t)).then((()=>S(this._send("RNTO "+e,!0))))}logout(){return S(this._send("QUIT"))}async listSafe(t,e){if("string"!=typeof t)return"boolean"==typeof t?this.list(t):this.list();{const s=await this.pwd();await this.cwd(t);try{return this.list(e||!1)}finally{s&&await this.cwd(s)}}}async fileInfo(t){const e=this._feat||[];let s;if(!1!==this._detectedSupport.mlst)for(const t of e){if(!t.startsWith("MLST "))continue;const e=t.substring(5).split(";");e.length&&!e[e.length-1]&&e.pop(),s=e;break}if(!s){const e=await this.list(t,!1);let s=null;if(1==e.length&&"string"!=typeof e[0])s=e[0];else for(const i of e)"string"==typeof i||"."!=i.name&&i.name!=t||s&&"."==s.name||(s=i);return s}const[i,n]=await y(S(this._send("MLST "+t,!1)));if(502==i)return this._detectedSupport.mlst=!1,this.fileInfo(t);const o=r(n||"");if("string"==typeof o)throw new Error(o);return o}async list(t,e){let i;const o=this._feat||[];let a;if(!1!==this._detectedSupport.mlst)for(const t of o){if(!t.startsWith("MLST "))continue;const e=t.substring(5).split(";");e.length&&!e[e.length-1]&&e.pop(),a=e;break}return"boolean"==typeof t&&(e=t,t=void 0),i=t&&a?"MLSD "+t:t?"LIST "+t:a?"MLSD":"LIST",this._pasv((async o=>{if(this._queue[0]&&"ABOR"===this._queue[0].cmd){const t=new Error("Aborted");throw t.code="aborted",t}let a,h=!1,u="";const l=new s("utf8");let f;e?(f=n.createInflate(),o.pipe(f)):f=o;const _=()=>{l&&(u+=l.end()),h=!0,k()};f.on("data",(t=>{u+="string"==typeof t?l.write(Buffer.from(t)):l.write(t)})),f.once("error",(t=>{o.aborting||(a=t)})),f.once("end",_),f.once("close",_);let w,m=null,v=null,y=null;const g=new Promise(((t,e)=>{m=t,v=e,y?t(y):void 0!==w&&e(w)}));let b=0;const T=async()=>{var e,s;const n=[];try{for(var o,r=d(this._send(i,!0));!(o=await r.next()).done;){const[t]=o.value;n.push(t),1==++b&&226===t&&(b=2)}}catch(t){e={error:t}}finally{try{o&&!o.done&&(s=r.return)&&await s.call(r)}finally{if(e)throw e.error}}if("string"==typeof t&&i.startsWith("MLSD ")&&501==n[n.length-1]){const e=await this.fileInfo(t);return{a:e?[e]:[]}}if(2===b)return k();throw new Error("Expected 2 replies for list, count: "+b+", codes: "+n.join(", "))},k=()=>{if(h&&2===b){if(b=3,a){const t=new Error("Unexpected data connection error: "+a);throw v?v(t):w=t,t}if(o.aborting){const t=new Error("Aborted");throw t.code="aborted",v?v(t):w=t,t}const t=u.split(p);this._debug&&this._debug("Listing entries: "+JSON.stringify(t)),t.pop();const e=[];if(i.startsWith("MLSD"))for(let s=0,i=t.length;s<i;++s){const i=r(t[s]);"string"!=typeof i?e.push(i):this._debug&&this._debug("Skipped entry listing: "+i+": "+JSON.stringify(t[s]))}else for(let s=0,i=t.length;s<i;++s){const i=c(t[s]);null!==i?e.push(i):this._debug&&this._debug("Skipped entry listing: "+JSON.stringify(t[s]))}const s={a:e};return m?m(s):y=s,Promise.resolve(s)}return g};if(!e)return T();await S(this._send("MODE Z",!0));try{return await T()}finally{await S(this._send("MODE S",!0))}})).then((t=>t.a))}get(t,e){return this._pasv((async s=>{if(this._queue[0]&&"ABOR"===this._queue[0].cmd){const t=new Error("Aborted");throw t.code="aborted",t}let i,o=!1,r=!1,c=s;if(e){c=n.createInflate(),s.pipe(c);const t=s.emit;s.emit=(e,...n)=>"error"===e?(i||(i=new Error(n.join(", "))),!0):(n.unshift(e),t.apply(s,n),!0)}let a,h=null,d=null,u=!1;const l=new Promise(((t,e)=>{h=t,d=e,u?t():void 0!==a&&e(a)})),p=c.emit;c.emit=(t,...e)=>"error"===t?(i||(i=new Error(e.join(", "))),d?d(i):a=i||null,!0):"end"===t||"close"===t?(r||(r=!0),h?h():u=!0,!0):(e.unshift(t),this._debug&&this._debug("Get source emit: "+JSON.stringify(e)),p.apply(c,e),!0),s.pause();const f=()=>new Promise((async(e,s)=>{try{e([S(await(async()=>{const e=this._send("RETR "+t,!0);for(;;){const t=await e.next();if(t.done)throw new Error("Expexted result RETR");const[s]=t.value;if(this._debug&&this._debug("Get code: "+s),150===s||125===s)return o=!0,e}})()).then((()=>l)),c])}catch(t){s(t)}}));if(e){await S(this._send("MODE Z",!0));try{return await f()}finally{await S(this._send("MODE S",!0));const t=()=>{r?(p.call(c,"end"),p.call(c,"close")):o&&(p.call(c,"error",i),p.call(c,"close",!0))};l.then(t,t)}}else try{return await f()}finally{const t=()=>{r?(p.call(c,"end"),p.call(c,"close")):o&&(p.call(c,"error",i),p.call(c,"close",!0))};l.then(t,t)}}))}put(t,e,s){return this._store("STOR "+e,t,s||!1)}append(t,e,s){return this._store("APPE "+e,t,s||!1)}async pwd(){if(!1!==this._detectedSupport.pwd){const[t,e]=await y(S(this._send("PWD")));if(502!=t)return e&&(f.exec(e)||[])[1]}return this._detectedSupport.pwd=!1,this.cwd(".",!0)}async cdup(){if(!1!==this._detectedSupport.cdup){const[t]=await y(S(this._send("CDUP")));if(502!=t)return}return this._detectedSupport.cdup=!1,this.cwd("..",!0)}async mkdir(t,e){if(!e)return void await S(this._send("MKD "+t));const s=await this.pwd(),i="/"===t[0],n=s;i&&(t=t.substring(1)),"/"===t[t.length-1]&&(t=t.substring(0,t.length-1));const o=t.split("/"),r=o.length,c=async()=>{var t,e;let s=-1,i=!0;if(++s!==r){if(!i)return await S(this._send("MKD "+o[s],!0)),await S(this._send("CWD "+o[s],!0)),c();try{for(var n,a=d(this._send("CWD "+o[s],!0));!(n=await a.next()).done;){const[t]=n.value;return 550===t&&(i=!1,--s),c()}}catch(e){t={error:e}}finally{try{n&&!n.done&&(e=a.return)&&await e.call(a)}finally{if(t)throw t.error}}}};try{i?(await S(this._send("CWD /",!0)),await c()):await c()}finally{await S(this._send("CWD "+n,!0))}}rmdir(t,e){return e?this.list(t).then((async e=>{for(const s of e){if("string"==typeof s)throw new Error("Cannot remove when listing is string");let e=null;if(e="/"===s.name[0]?s.name:"/"===t[t.length-1]?t+s.name:t+"/"+s.name,"d"===s.type){if("."===s.name||".."===s.name)continue;await this.rmdir(e,!0)}else await this.delete(e)}return S(this._send("RMD "+t))})):S(this._send("RMD "+t))}async system(){const t=(await S(this._send("SYST")))[1];return t&&(_.exec(t)||[])[1]||""}async size(t){let e,s=502;return!1!==this._detectedSupport.size&&([s,e]=await y(S(this._send("SIZE "+t)))),502===s?(this._detectedSupport.size=!1,this.fileInfo(t).then((e=>{if(!e)throw new Error("Unable to get info for path "+JSON.stringify(t));if("d"==e.type)throw new Error("Can not get the size of a directory");if(-1!=e.size)return e.size;throw new Error("File not found")}))):e?parseInt(e,10):-1}async lastMod(t){let e,s=502;if(!1!==this._detectedSupport.mdtm&&([s,e]=await y(S(this._send("MDTM "+t)))),502===s)return this._detectedSupport.mdtm=!1,this.fileInfo(t).then((e=>{if(e&&e.date)return e.date;throw new Error("No modification time available for file "+JSON.stringify(t))}));if(s>=400)throw Object.assign(new Error("Error for modification time ("+s+"): "+e),{code:s});const i=(t=>{const e=t&&t.match(v);if(e)return{date:e[3],hour:e[4],minute:e[5],month:e[2],second:e[6],year:e[1]}})(e);if(!i)throw new Error("Invalid date/time format from server");return new Date(i.year+"-"+i.month+"-"+i.date+"T"+i.hour+":"+i.minute+":"+i.second)}restart(t){return S(this._send("REST "+t))}localPort(t,s){const i=e.isIP(t);if(0==i)throw new Error("Invalid IP: "+t);return[t=4==i?"0.0.0.0":"::",s||"5000-8000"]}async _pasv(t){let s,i,n=!0;const o=()=>{var t,e;const s=this._feat||[];return 0!=s.length&&!s.includes("EPSV")&&[void 0,"IPv4"].includes(null===(t=this._socket)||void 0===t?void 0:t.remoteFamily)||!1===this._detectedSupport.epsv?(0==s.length||s.includes("PASV"))&&!1!==this._detectedSupport.pasv&&[void 0,"IPv4"].includes(null===(e=this._socket)||void 0===e?void 0:e.remoteFamily)?"PASV":"":"EPSV"};let r="";const c=async([t,e])=>{if(this._curReq=void 0,!n||r&&"PASV"!=r){if(n){const t=e&&l.exec(e);if(!t)throw new Error("Unable to parse EPSV server response");s=this._socket.remoteAddress,i=parseInt(t[2],10),n=!1}}else{const t=e&&u.exec(e);if(!t)throw new Error("Unable to parse PASV server response");s=t[1],s+=".",s+=t[2],s+=".",s+=t[3],s+=".",s+=t[4],i=parseInt(t[5],10)<<8|parseInt(t[6],10),n=!1}const o=await this._pasvConnect(s,i).catch((t=>this._socket&&s!==this._socket.remoteAddress?(s=this._socket.remoteAddress,c([0,""])):S(this._send("ABOR",!0)).then((()=>{throw S(this._send()),t}))));return S(this._send()),o},a=async t=>{const e=await this._portConnect(t).catch((t=>S(this._send("ABOR",!0)).then((()=>{throw S(this._send()),t}))));return S(this._send()),e},h=async()=>{const s=this.options.portAddress;if(r=o(),r||!s)return S(this._send(r||"PASV")).then((async e=>{const s=await c(e),i=await t(s);return Array.isArray(i)?[i[0].then((()=>s.destroy()),(()=>s.destroy())),i[1]]:(s.destroy(),[Promise.resolve(),i])}),(t=>{if(500!=t.code&&502!=t.code||!r||("PASV"==r?this._detectedSupport.pasv=!1:"EPSV"==r&&(this._detectedSupport.epsv=!1)),!s&&!r)throw t;return h()}));{const i=e.isIP(s);if(4!=i&&6!=i)throw new Error("Invalid `portAddress`, must be IPv4 or IPv6: "+JSON.stringify(s));const[n,o]=await this.localPort(s,this.options.portRange),r=e.isIP(n);if(4!=r&&6!=r)throw new Error("Invalid `bindIp`, must be IPv4 or IPv6: "+JSON.stringify(n));if(!(4==r||this._feat&&this._feat.includes("EPRT")&&!1!==this._detectedSupport.eprt))throw new Error("Only IPv4 may be used for `bindIp` when connecting to servers without `EPRT` support");const c=await((t,s)=>new Promise(((i,n)=>{if(t){const o=e.createServer();let[r,c]="string"==typeof t?t.split("-",2).map((t=>t?parseInt(t,10):0)):[t,t];r||(r=1),(!c||c>65535)&&(c=65535),o.maxConnections=1;const a=()=>{r<c?(r++,o.listen(r,s)):n(new Error("Unable to find available port"))};o.on("error",a),o.on("listening",(()=>{o.removeListener("error",a),i(o)})),o.listen(r,s)}else n(new Error("Invalid `portRange`"))})))(o||"5000-8000",n),h=a(c),d=c.address(),u="string"!=typeof d?d.port:0;let l;if(4==r){const t=u>>8,e=255&u;l="PORT "+s.replace(/\./g,",")+","+t+","+e}else l="EPRT |2|"+s+"|"+u+"|";await S(this._send(l));const p=await h,f=await t(p).catch((t=>{throw t}));return Array.isArray(f)?[f[0].then((()=>p.destroy()),(()=>p.destroy())),f[1]]:(p.destroy(),[Promise.resolve(),f])}},d=this._pasvReady.then(h);return this._pasvReady=d.then((t=>t[0]),(()=>{})),d.then((t=>t[1]))}_portConnect(t){return new Promise(((e,s)=>{let i=null,n=!1;const o=setTimeout((()=>{n=!0,t.close(),s(new Error("Timed out while making data connection"))}),this.options.dataTimeout);t.on("connection",(r=>{this._pasvSocket=r,clearTimeout(o),this._debug&&this._debug("[connection] PORT socket connected"),r.once("error",(t=>{i=t,s(i)})),r.once("close",(()=>{if(!this._pasvSocket&&!n){let t="Unable to make data connection";i&&(t+="( "+i+")",i=null),s(new Error(t))}this._pasvSocket=void 0,t.close()})),e(r)})),t.on("error",s),t.on("close",(()=>{if(!this._pasvSocket&&!n){let t="Unable to make data connection";i&&(t+="( "+i+")",i=null),s(new Error(t))}this._pasvSocket=void 0}))}))}_pasvConnect(t,s){return new Promise(((n,o)=>{let r=new e.Socket,c=null,a=!1;const h=setTimeout((()=>{a=!0,r.destroy(),o(new Error("Timed out while making data connection"))}),this.options.dataTimeout);r.setTimeout(0),r.once("connect",(()=>{this._debug&&this._debug("[connection] PASV socket connected"),!0===this.options.secure&&(this.options.secureOptions=this.options.secureOptions||{},this.options.secureOptions.socket=r,this.options.secureOptions.session=this._socket.getSession(),r=i.connect(this.options.secureOptions),r.setTimeout(0)),clearTimeout(h),this._pasvSocket=r,n(r)})),r.once("error",(t=>{c=t,o(c)})),r.once("end",(()=>{clearTimeout(h)})),r.once("close",(()=>{if(clearTimeout(h),!this._pasvSocket&&!a){let t="Unable to make data connection";c&&(t+="( "+c+")",c=null),o(new Error(t))}this._pasvSocket=void 0})),r.connect(s,t)}))}_store(t,e,s){return Buffer.isBuffer(e)||"string"==typeof e||void 0===e.pause||e.pause(),this._pasv((async i=>{if(this._queue[0]&&"ABOR"===this._queue[0].cmd){const t=new Error("Aborted");throw t.code="aborted",t}let o=null;i.once("error",(t=>{o=t}));const r=async s=>{var i,n;try{for(var o,r=d(this._send(t,!0));!(o=await r.next()).done;){const[t]=o.value;150!==t&&125!==t||(Buffer.isBuffer(e)?(s.write(e),s.end()):"string"==typeof e?await import("fs").then((t=>{t.stat(e,(i=>{i?s.end():t.createReadStream(e).pipe(s)}))})):(e.pipe(s),e.resume()))}}catch(t){i={error:t}}finally{try{o&&!o.done&&(n=r.return)&&await n.call(r)}finally{if(i)throw i.error}}};try{if(!s)return r(i);{await S(this._send("MODE Z",!0));const t=n.createDeflate({level:8});try{return t.pipe(i),r(t)}finally{t.end(),await S(this._send("MODE S",!0))}}}catch(t){throw t||o}}))}_reset(){this._pasvSock&&this._pasvSock.writable&&this._pasvSock.end(),this._socket&&this._socket.writable&&this._socket.end(),this._socket=void 0,this._pasvSock=void 0,this._feat=void 0,this._curReq=void 0,this._secstate=void 0,this._keepalive&&(clearTimeout(this._keepalive),this._keepalive=void 0),this._queue=[],this._ending=!1,this._parser=void 0,this.options.host=this.options.port=this.options.user=this.options.password=this.options.secure=this.options.connTimeout=this.options.dataTimeout=this.options.keepalive=this._debug=void 0,this.connected=!1}}class ErrorWithCode extends Error{constructor(t,e){super(e||""+t),this.code=t}}function m(t,e){return new ErrorWithCode(t,e)}const v=/^(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})(\d+)(?:.\d+)?$/;async function y(t){try{return await t}catch(t){if(t instanceof ErrorWithCode&&(500==t.code||502==t.code))return[502,t.message];throw t}}async function S(t){let e,s;do{e=await t.next(),e.done&&!e.value||(s=e.value)}while(!e.done);return s}export{ErrorWithCode,FTP,FTP as default};
//# sourceMappingURL=connection.mjs.map
