Object.defineProperty(exports,"__esModule",{value:!0});var t=require("events"),e=require("net"),s=require("string_decoder"),i=require("tls"),r=require("zlib"),n=require("./parser.js");function o(t){return t&&"object"==typeof t&&"default"in t?t:{default:t}}function c(t){if(t&&t.__esModule)return t;var e=Object.create(null);return t&&Object.keys(t).forEach((s=>{if("default"!==s){var i=Object.getOwnPropertyDescriptor(t,s);Object.defineProperty(e,s,i.get?i:{enumerable:!0,get:()=>t[s]})}})),e.default=t,Object.freeze(e)}require("stream");var a=o(t),h=c(e),d=c(i),u=o(r);function l(t){return this instanceof l?(this.v=t,this):new l(t)}function p(t,e,s){if(!Symbol.asyncIterator)throw new TypeError("Symbol.asyncIterator is not defined.");var i,r=s.apply(t,e||[]),n=[];return i={},o("next"),o("throw"),o("return"),i[Symbol.asyncIterator]=function(){return this},i;function o(t){r[t]&&(i[t]=e=>new Promise(((s,i)=>{n.push([t,e,s,i])>1||c(t,e)})))}function c(t,e){try{(s=r[t](e)).value instanceof l?Promise.resolve(s.value.v).then(a,h):d(n[0][2],s)}catch(t){d(n[0][3],t)}var s}function a(t){c("next",t)}function h(t){c("throw",t)}function d(t,e){t(e),n.shift(),n.length&&c(n[0][0],n[0][1])}}function f(t){if(!Symbol.asyncIterator)throw new TypeError("Symbol.asyncIterator is not defined.");var e,s=t[Symbol.asyncIterator];return s?s.call(t):(t=function(t){var e="function"==typeof Symbol&&Symbol.iterator,s=e&&t[e],i=0;if(s)return s.call(t);if(t&&"number"==typeof t.length)return{next(){return t&&i>=t.length&&(t=void 0),{value:t&&t[i++],done:!t}}};throw new TypeError(e?"Object is not iterable.":"Symbol.iterator is not defined.")}(t),e={},i("next"),i("throw"),i("return"),e[Symbol.asyncIterator]=function(){return this},e);function i(s){e[s]=t[s]&&(e=>new Promise(((i,r)=>{((t,e,s,i)=>{Promise.resolve(i).then((e=>{t({value:e,done:s})}),e)})(i,r,(e=t[s](e)).done,e.value)})))}}const _=/(\d+),(\d+),(\d+),(\d+),([-\d]+),([-\d]+)/,w=/\((.)\1\1(\d+)\1\)/,m=/\r?\n/g,y=/"(.+)"(?: |$)/,v=/^([^ ]+)(?: |$)/,S=Buffer.from("NOOP\r\n");class FTP extends a.default{constructor(){super(...arguments),this.options={secure:!1},this.connected=!1,this._pasvReady=Promise.resolve(),this._queue=[],this._ending=!1,this._detectedSupport={},this._send=function(t,e){return p(this,arguments,(function*(){let s=null,i=null,r=null,n=null;if(this._keepalive&&(clearTimeout(this._keepalive),this._keepalive=void 0),void 0!==t){const o=(t,e,o)=>{t?n?n(t):i=t:r?r([o,e]):s=[o,e]};e?this._queue.unshift({cmd:t,cb:o}):this._queue.push({cmd:t,cb:o})}const o=this._queue.length;!this._curReq&&o&&this._socket&&this._socket.readable?(this._curReq=this._queue.shift(),"ABOR"===this._curReq.cmd&&this._pasvSocket&&(this._pasvSocket.aborting=!0),this._debug&&this._debug("[connection] > "+this._curReq.cmd),this._socket.write(this._curReq.cmd+"\r\n")):this._curReq||o||!this._ending||this._reset();let c=!1;for(;!c;){const t=new Promise(((t,e)=>{r=t,n=e,s?r(s):null!==i&&n(i)})),e=yield l(t);r=null,n=null,s=null,i=null,c=void 0===this._curReq,yield yield l(e)}}))}}static async connect(t={}){const e=new FTP;try{return await e.connect(t)}catch(t){throw e.logout().catch((t=>t)),t}}get feat(){return this._feat}connect(t={}){return new Promise(((e,s)=>{let i=!0;this.connected=!1,this.options.host=t.host||"localhost",this.options.port=t.port||21,this.options.user=t.user||"anonymous",this.options.password=t.password||""===t.password?t.password:"anonymous@",this.options.secure=t.secure||!1,this.options.secureOptions=t.secureOptions,this.options.connTimeout=t.connTimeout||1e4,this.options.dataTimeout=t.dataTimeout||t.pasvTimeout||1e4,this.options.aliveTimeout=t.keepalive||1e4,this.options.portAddress=t.portAddress,this.options.portRange=t.portRange,this.options.overrideFeats=t.overrideFeats,"function"==typeof t.debug&&(this._debug=t.debug);const r={},o=this._debug;let c=new h.Socket;if(c.setTimeout(0),c.setKeepAlive(!0),this._parser=new n.default({debug:o}),this._parser.on("response",((t,e)=>{const r=t/100|0;if(4===r||5===r)if(this._curReq){const s=this._curReq;this._curReq=void 0,s.cb(g(t,e),void 0,t),E(this._send())}else{const r=g(t,e);this.emit("error",r),i&&(s(r),i=!1)}else if(this._curReq){const s=this._curReq;1!==r?(this._curReq=void 0,s.cb(void 0,e,t),E(this._send())):s.cb(void 0,e,t)}a.cb()})),this.options.secure){r.host=this.options.host;const t=this.options.secureOptions;t&&Object.assign(r,t),r.socket=c,this.options.secureOptions=r}const a={cb:()=>{this._keepalive&&clearTimeout(this._keepalive),this._keepalive=setTimeout(u,this.options.aliveTimeout)},cmd:"NOOP"},u=()=>{this._socket&&this._socket.writable?this._curReq||0!==this._queue.length?a.cb():(this._curReq=a,o&&o("[connection] > NOOP"),this._socket.write(S)):this._keepalive&&(clearTimeout(this._keepalive),this._keepalive=void 0)},l=()=>{let t;clearTimeout(m),this._keepalive&&(clearTimeout(this._keepalive),this._keepalive=void 0),this.connected=!0,this._socket=c;const e=([s,o])=>{if("AUTH TLS"===t&&234!==s&&!0!==this.options.secure||"AUTH SSL"===t&&334!==s||"PBSZ"===t&&200!==s||"PROT"===t&&200!==s){const t=new ErrorWithCode(s,"Unable to secure connection(s)");throw this.emit("error",t),this._socket&&this._socket.end(),t}if(t){if("USER"===t){if(230!==s){if(!this.options.password&&""!==this.options.password){const t=g(s,"Password required");throw this.emit("error",t),this._socket&&this._socket.end(),t}return t="PASS",E(this._send("PASS "+this.options.password,!0)).then(e)}return t="PASS",e([s,o])}if("PASS"===t)return t="FEAT",E(this._send(t,!0)).then((t=>(t[1]&&(this._feat=n.default.parseFeat(t[1])),t)),(t=>{if(500!==t.code)throw t;return[t.code,t.message]})).then((t=>{this._feat||(this._feat=[]);const e=this.options.overrideFeats;if(e)for(const t of Object.keys(e)){const s=e[t];if("boolean"!=typeof s)if("string"!=typeof s);else{const e=this._feat.findIndex((e=>e==t||e.startsWith(t+" ")));if(-1==e){this._feat.push(t+" "+s);continue}this._feat[e]=t+" "+s}else{const e=this._feat.findIndex((e=>e==t||e.startsWith(t+" ")));if(-1==e&&s){this._feat.push(t);continue}if(-1!=e&&!s){this._feat.splice(e,1);continue}}}return t})).then(e);if("FEAT"===t)return t="TYPE",E(this._send("TYPE I",!0)).then(e);if("TYPE"===t)return this.emit("ready"),i=!1,this;if("PBSZ"===t)return t="PROT",E(this._send("PROT P",!0)).then(e);if("PROT"===t)return t="USER",E(this._send("USER "+this.options.user,!0)).then(e);if("AUTH"===t.substring(0,4))return"AUTH TLS"===t&&234!==s?(t="AUTH SSL",E(this._send(t,!0)).then(e)):("AUTH TLS"===t?this._secstate="upgraded-tls":"AUTH SSL"===t&&(this._secstate="upgraded-ssl"),c.removeAllListeners("data"),c.removeAllListeners("error"),this._curReq=void 0,r.socket=this._socket,r.session=void 0,new Promise((t=>{c=d.connect(r,(()=>t(l()))),c.setEncoding("binary"),c.on("data",p),c.once("end",_),c.on("error",f)})));throw new Error("No matched command: "+JSON.stringify(t))}return this.emit("greeting",o),this.options.secure&&"implicit"!==this.options.secure?(t="AUTH TLS",E(this._send(t,!0)).then(e)):(t="USER",E(this._send("USER "+this.options.user,!0)).then(e))},s=t=>{throw c.destroyed&&c.end(),t};if(this._secstate)return"upgraded-tls"===this._secstate&&!0===this.options.secure?(t="PBSZ",E(this._send("PBSZ 0",!0)).then(e).catch(s)):(t="USER",E(this._send("USER "+this.options.user,!0)).then(e).catch(s));{let t,i=null,r=null,n=null;const o=new Promise(((e,s)=>{i=e,r=s,n?e(n):void 0!==t&&s(t)}));return this._curReq={cb(s,o,c){s?r?r(s):t=s:i?i(e([c,o])):n=e([c,o])},cmd:""},o.catch(s)}};"implicit"===this.options.secure?this._socket=d.connect(r,(()=>l().then(e,s))):(c.once("connect",(()=>l().then(e,s))),this._socket=c);const p=t=>{o&&o("[connection] < "+t.toString("binary")),this._parser.write(t)};c.on("data",p);const f=t=>{clearTimeout(m),this._keepalive&&(clearTimeout(this._keepalive),this._keepalive=void 0),i?(s(t),i=!1,this._socket&&!this._socket.destroyed&&this._socket.end()):this.listenerCount("error")&&this.emit("error",t)};c.on("error",f);const _=()=>{w||(w=!0,clearTimeout(m),this._reset()),this.emit("end"),i&&(s("End before ready"),i=!1)};c.once("end",_),c.once("close",(t=>{w||(w=!0,clearTimeout(m),this._reset()),this.emit("close",t),i&&(s("Close before ready"),i=!1)}));let w=!1;const m=setTimeout((()=>{!this.listenerCount("error")&&i||this.emit("error",new Error("Timeout while connecting to server")),this._socket&&this._socket.destroy(),this._reset(),i&&(s(new Error("Timeout while connecting to server")),i=!1)}),this.options.connTimeout);try{this._socket.connect(this.options.port,this.options.host)}catch(t){s(t)}}))}end(){this._queue.length||this._curReq?this._ending=!0:this._reset()}destroy(){this._reset()}ascii(){return E(this._send("TYPE A"))}binary(){return E(this._send("TYPE I"))}abort(t=!0){return E(this._send("ABOR",Boolean(t)))}cwd(t,e){return E(this._send("CWD "+t,e)).then((([t,e])=>{const s=e&&y.exec(e);return s?s[1]:void 0}))}delete(t){return E(this._send("DELE "+t))}site(t){return E(this._send("SITE "+t))}status(){return E(this._send("STAT")).then((([t,e])=>e))}rename(t,e){return E(this._send("RNFR "+t)).then((()=>E(this._send("RNTO "+e,!0))))}logout(){return E(this._send("QUIT"))}async listSafe(t,e){if("string"!=typeof t)return"boolean"==typeof t?this.list(t):this.list();{const s=await this.pwd();await this.cwd(t);try{return this.list(e||!1)}finally{s&&await this.cwd(s)}}}async fileInfo(t){const e=this._feat||[];let s;if(!1!==this._detectedSupport.mlst)for(const t of e){if(!t.startsWith("MLST "))continue;const e=t.substring(5).split(";");e.length&&!e[e.length-1]&&e.pop(),s=e;break}if(!s){const e=await this.list(t,!1);let s=null;if(1==e.length&&"string"!=typeof e[0])s=e[0];else for(const i of e)"string"==typeof i||"."!=i.name&&i.name!=t||s&&"."==s.name||(s=i);return s}const[i,r]=await T(E(this._send("MLST "+t,!1)));if(502==i)return this._detectedSupport.mlst=!1,this.fileInfo(t);const o=n.parseMlsxEntry(r||"");if("string"==typeof o)throw new Error(o);return o}async list(t,e){let i;const r=this._feat||[];let o;if(!1!==this._detectedSupport.mlst)for(const t of r){if(!t.startsWith("MLST "))continue;const e=t.substring(5).split(";");e.length&&!e[e.length-1]&&e.pop(),o=e;break}return"boolean"==typeof t&&(e=t,t=void 0),i=t&&o?"MLSD "+t:t?"LIST "+t:o?"MLSD":"LIST",this._pasv((async r=>{if(this._queue[0]&&"ABOR"===this._queue[0].cmd){const t=new Error("Aborted");throw t.code="aborted",t}let o,c=!1,a="";const h=new s.StringDecoder("utf8");let d;e?(d=u.default.createInflate(),r.pipe(d)):d=r;const l=()=>{h&&(a+=h.end()),c=!0,b()};d.on("data",(t=>{a+="string"==typeof t?h.write(Buffer.from(t)):h.write(t)})),d.once("error",(t=>{r.aborting||(o=t)})),d.once("end",l),d.once("close",l);let p,_=null,w=null,y=null;const v=new Promise(((t,e)=>{_=t,w=e,y?t(y):void 0!==p&&e(p)}));let S=0;const g=async()=>{var e,s;const r=[];try{for(var n,o=f(this._send(i,!0));!(n=await o.next()).done;){const[t]=n.value;r.push(t),1==++S&&226===t&&(S=2)}}catch(t){e={error:t}}finally{try{n&&!n.done&&(s=o.return)&&await s.call(o)}finally{if(e)throw e.error}}if("string"==typeof t&&i.startsWith("MLSD ")&&501==r[r.length-1]){const e=await this.fileInfo(t);return{a:e?[e]:[]}}if(2===S)return b();throw new Error("Expected 2 replies for list, count: "+S+", codes: "+r.join(", "))},b=()=>{if(c&&2===S){if(S=3,o){const t=new Error("Unexpected data connection error: "+o);throw w?w(t):p=t,t}if(r.aborting){const t=new Error("Aborted");throw t.code="aborted",w?w(t):p=t,t}const t=a.split(m);this._debug&&this._debug("Listing entries: "+JSON.stringify(t)),t.pop();const e=[];if(i.startsWith("MLSD"))for(let s=0,i=t.length;s<i;++s){const i=n.parseMlsxEntry(t[s]);"string"!=typeof i?e.push(i):this._debug&&this._debug("Skipped entry listing: "+i+": "+JSON.stringify(t[s]))}else for(let s=0,i=t.length;s<i;++s){const i=n.parseListEntry(t[s]);null!==i?e.push(i):this._debug&&this._debug("Skipped entry listing: "+JSON.stringify(t[s]))}const s={a:e};return _?_(s):y=s,Promise.resolve(s)}return v};if(!e)return g();await E(this._send("MODE Z",!0));try{return await g()}finally{await E(this._send("MODE S",!0))}})).then((t=>t.a))}get(t,e){return this._pasv((async s=>{if(this._queue[0]&&"ABOR"===this._queue[0].cmd){const t=new Error("Aborted");throw t.code="aborted",t}let i,r=!1,n=!1,o=s;if(e){o=u.default.createInflate(),s.pipe(o);const t=s.emit;s.emit=(e,...r)=>"error"===e?(i||(i=new Error(r.join(", "))),!0):(r.unshift(e),t.apply(s,r),!0)}let c,a=null,h=null,d=!1;const l=new Promise(((t,e)=>{a=t,h=e,d?t():void 0!==c&&e(c)})),p=o.emit;o.emit=(t,...e)=>"error"===t?(i||(i=new Error(e.join(", "))),h?h(i):c=i||null,!0):"end"===t||"close"===t?(n||(n=!0),a?a():d=!0,!0):(e.unshift(t),this._debug&&this._debug("Get source emit: "+JSON.stringify(e)),p.apply(o,e),!0),s.pause();const f=()=>new Promise((async(e,s)=>{try{e([E(await(async()=>{const e=this._send("RETR "+t,!0);for(;;){const t=await e.next();if(t.done)throw new Error("Expexted result RETR");const[s]=t.value;if(this._debug&&this._debug("Get code: "+s),150===s||125===s)return r=!0,e}})()).then((()=>l)),o])}catch(t){s(t)}}));if(e){await E(this._send("MODE Z",!0));try{return await f()}finally{await E(this._send("MODE S",!0));const t=()=>{n?(p.call(o,"end"),p.call(o,"close")):r&&(p.call(o,"error",i),p.call(o,"close",!0))};l.then(t,t)}}else try{return await f()}finally{const t=()=>{n?(p.call(o,"end"),p.call(o,"close")):r&&(p.call(o,"error",i),p.call(o,"close",!0))};l.then(t,t)}}))}put(t,e,s){return this._store("STOR "+e,t,s||!1)}append(t,e,s){return this._store("APPE "+e,t,s||!1)}async pwd(){if(!1!==this._detectedSupport.pwd){const[t,e]=await T(E(this._send("PWD")));if(502!=t)return e&&(y.exec(e)||[])[1]}return this._detectedSupport.pwd=!1,this.cwd(".",!0)}async cdup(){if(!1!==this._detectedSupport.cdup){const[t]=await T(E(this._send("CDUP")));if(502!=t)return}return this._detectedSupport.cdup=!1,this.cwd("..",!0)}async mkdir(t,e){if(!e)return void await E(this._send("MKD "+t));const s=await this.pwd(),i="/"===t[0],r=s;i&&(t=t.substring(1)),"/"===t[t.length-1]&&(t=t.substring(0,t.length-1));const n=t.split("/"),o=n.length,c=async()=>{var t,e;let s=-1,i=!0;if(++s!==o){if(!i)return await E(this._send("MKD "+n[s],!0)),await E(this._send("CWD "+n[s],!0)),c();try{for(var r,a=f(this._send("CWD "+n[s],!0));!(r=await a.next()).done;){const[t]=r.value;return 550===t&&(i=!1,--s),c()}}catch(e){t={error:e}}finally{try{r&&!r.done&&(e=a.return)&&await e.call(a)}finally{if(t)throw t.error}}}};try{i?(await E(this._send("CWD /",!0)),await c()):await c()}finally{await E(this._send("CWD "+r,!0))}}rmdir(t,e){return e?this.list(t).then((async e=>{for(const s of e){if("string"==typeof s)throw new Error("Cannot remove when listing is string");let e=null;if(e="/"===s.name[0]?s.name:"/"===t[t.length-1]?t+s.name:t+"/"+s.name,"d"===s.type){if("."===s.name||".."===s.name)continue;await this.rmdir(e,!0)}else await this.delete(e)}return E(this._send("RMD "+t))})):E(this._send("RMD "+t))}async system(){const t=(await E(this._send("SYST")))[1];return t&&(v.exec(t)||[])[1]||""}async size(t){let e,s=502;return!1!==this._detectedSupport.size&&([s,e]=await T(E(this._send("SIZE "+t)))),502===s?(this._detectedSupport.size=!1,this.fileInfo(t).then((e=>{if(!e)throw new Error("Unable to get info for path "+JSON.stringify(t));if("d"==e.type)throw new Error("Can not get the size of a directory");if(-1!=e.size)return e.size;throw new Error("File not found")}))):e?parseInt(e,10):-1}async lastMod(t){let e,s=502;if(!1!==this._detectedSupport.mdtm&&([s,e]=await T(E(this._send("MDTM "+t)))),502===s)return this._detectedSupport.mdtm=!1,this.fileInfo(t).then((e=>{if(e&&e.date)return e.date;throw new Error("No modification time available for file "+JSON.stringify(t))}));if(s>=400)throw Object.assign(new Error("Error for modification time ("+s+"): "+e),{code:s});const i=(t=>{const e=t&&t.match(b);if(e)return{date:e[3],hour:e[4],minute:e[5],month:e[2],second:e[6],year:e[1]}})(e);if(!i)throw new Error("Invalid date/time format from server");return new Date(i.year+"-"+i.month+"-"+i.date+"T"+i.hour+":"+i.minute+":"+i.second)}restart(t){return E(this._send("REST "+t))}localPort(t,e){const s=h.isIP(t);if(0==s)throw new Error("Invalid IP: "+t);return[t=4==s?"0.0.0.0":"::",e||"5000-8000"]}async _pasv(t){let e,s,i=!0;const r=()=>{var t,e;const s=this._feat||[];return 0!=s.length&&!s.includes("EPSV")&&[void 0,"IPv4"].includes(null===(t=this._socket)||void 0===t?void 0:t.remoteFamily)||!1===this._detectedSupport.epsv?(0==s.length||s.includes("PASV"))&&!1!==this._detectedSupport.pasv&&[void 0,"IPv4"].includes(null===(e=this._socket)||void 0===e?void 0:e.remoteFamily)?"PASV":"":"EPSV"};let n="";const o=async([t,r])=>{if(this._curReq=void 0,!i||n&&"PASV"!=n){if(i){const t=r&&w.exec(r);if(!t)throw new Error("Unable to parse EPSV server response");e=this._socket.remoteAddress,s=parseInt(t[2],10),i=!1}}else{const t=r&&_.exec(r);if(!t)throw new Error("Unable to parse PASV server response");e=t[1],e+=".",e+=t[2],e+=".",e+=t[3],e+=".",e+=t[4],s=parseInt(t[5],10)<<8|parseInt(t[6],10),i=!1}const c=await this._pasvConnect(e,s).catch((t=>this._socket&&e!==this._socket.remoteAddress?(e=this._socket.remoteAddress,o([0,""])):E(this._send("ABOR",!0)).then((()=>{throw E(this._send()),t}))));return E(this._send()),c},c=async t=>{const e=await this._portConnect(t).catch((t=>E(this._send("ABOR",!0)).then((()=>{throw E(this._send()),t}))));return E(this._send()),e},a=async()=>{const e=this.options.portAddress;if(n=r(),n||!e)return E(this._send(n||"PASV")).then((async e=>{const s=await o(e),i=await t(s);return Array.isArray(i)?[i[0].then((()=>s.destroy()),(()=>s.destroy())),i[1]]:(s.destroy(),[Promise.resolve(),i])}),(t=>{if(500!=t.code&&502!=t.code||!n||("PASV"==n?this._detectedSupport.pasv=!1:"EPSV"==n&&(this._detectedSupport.epsv=!1)),!e&&!n)throw t;return a()}));{const s=h.isIP(e);if(4!=s&&6!=s)throw new Error("Invalid `portAddress`, must be IPv4 or IPv6: "+JSON.stringify(e));const[i,r]=await this.localPort(e,this.options.portRange),n=h.isIP(i);if(4!=n&&6!=n)throw new Error("Invalid `bindIp`, must be IPv4 or IPv6: "+JSON.stringify(i));if(!(4==n||this._feat&&this._feat.includes("EPRT")&&!1!==this._detectedSupport.eprt))throw new Error("Only IPv4 may be used for `bindIp` when connecting to servers without `EPRT` support");const o=await((t,e)=>new Promise(((s,i)=>{if(t){const r=h.createServer();let[n,o]="string"==typeof t?t.split("-",2).map((t=>t?parseInt(t,10):0)):[t,t];n||(n=1),(!o||o>65535)&&(o=65535),r.maxConnections=1;const c=()=>{n<o?(n++,r.listen(n,e)):i(new Error("Unable to find available port"))};r.on("error",c),r.on("listening",(()=>{r.removeListener("error",c),s(r)})),r.listen(n,e)}else i(new Error("Invalid `portRange`"))})))(r||"5000-8000",i),a=c(o),d=o.address(),u="string"!=typeof d?d.port:0;let l;if(4==n){const t=u>>8,s=255&u;l="PORT "+e.replace(/\./g,",")+","+t+","+s}else l="EPRT |2|"+e+"|"+u+"|";await E(this._send(l));const p=await a,f=await t(p).catch((t=>{throw t}));return Array.isArray(f)?[f[0].then((()=>p.destroy()),(()=>p.destroy())),f[1]]:(p.destroy(),[Promise.resolve(),f])}},d=this._pasvReady.then(a);return this._pasvReady=d.then((t=>t[0]),(()=>{})),d.then((t=>t[1]))}_portConnect(t){return new Promise(((e,s)=>{let i=null,r=!1;const n=setTimeout((()=>{r=!0,t.close(),s(new Error("Timed out while making data connection"))}),this.options.dataTimeout);t.on("connection",(o=>{this._pasvSocket=o,clearTimeout(n),this._debug&&this._debug("[connection] PORT socket connected"),o.once("error",(t=>{i=t,s(i)})),o.once("close",(()=>{if(!this._pasvSocket&&!r){let t="Unable to make data connection";i&&(t+="( "+i+")",i=null),s(new Error(t))}this._pasvSocket=void 0,t.close()})),e(o)})),t.on("error",s),t.on("close",(()=>{if(!this._pasvSocket&&!r){let t="Unable to make data connection";i&&(t+="( "+i+")",i=null),s(new Error(t))}this._pasvSocket=void 0}))}))}_pasvConnect(t,e){return new Promise(((s,i)=>{let r=new h.Socket,n=null,o=!1;const c=setTimeout((()=>{o=!0,r.destroy(),i(new Error("Timed out while making data connection"))}),this.options.dataTimeout);r.setTimeout(0),r.once("connect",(()=>{this._debug&&this._debug("[connection] PASV socket connected"),!0===this.options.secure&&(this.options.secureOptions=this.options.secureOptions||{},this.options.secureOptions.socket=r,this.options.secureOptions.session=this._socket.getSession(),r=d.connect(this.options.secureOptions),r.setTimeout(0)),clearTimeout(c),this._pasvSocket=r,s(r)})),r.once("error",(t=>{n=t,i(n)})),r.once("end",(()=>{clearTimeout(c)})),r.once("close",(()=>{if(clearTimeout(c),!this._pasvSocket&&!o){let t="Unable to make data connection";n&&(t+="( "+n+")",n=null),i(new Error(t))}this._pasvSocket=void 0})),r.connect(e,t)}))}_store(t,e,s){return Buffer.isBuffer(e)||"string"==typeof e||void 0===e.pause||e.pause(),this._pasv((async i=>{if(this._queue[0]&&"ABOR"===this._queue[0].cmd){const t=new Error("Aborted");throw t.code="aborted",t}let r=null;i.once("error",(t=>{r=t}));const n=async s=>{var i,r;try{for(var n,o=f(this._send(t,!0));!(n=await o.next()).done;){const[t]=n.value;150!==t&&125!==t||(Buffer.isBuffer(e)?(s.write(e),s.end()):"string"==typeof e?await Promise.resolve().then((()=>c(require("fs")))).then((t=>{t.stat(e,(i=>{i?s.end():t.createReadStream(e).pipe(s)}))})):(e.pipe(s),e.resume()))}}catch(t){i={error:t}}finally{try{n&&!n.done&&(r=o.return)&&await r.call(o)}finally{if(i)throw i.error}}};try{if(!s)return n(i);{await E(this._send("MODE Z",!0));const t=u.default.createDeflate({level:8});try{return t.pipe(i),n(t)}finally{t.end(),await E(this._send("MODE S",!0))}}}catch(t){throw t||r}}))}_reset(){this._pasvSock&&this._pasvSock.writable&&this._pasvSock.end(),this._socket&&this._socket.writable&&this._socket.end(),this._socket=void 0,this._pasvSock=void 0,this._feat=void 0,this._curReq=void 0,this._secstate=void 0,this._keepalive&&(clearTimeout(this._keepalive),this._keepalive=void 0),this._queue=[],this._ending=!1,this._parser=void 0,this.options.host=this.options.port=this.options.user=this.options.password=this.options.secure=this.options.connTimeout=this.options.dataTimeout=this.options.keepalive=this._debug=void 0,this.connected=!1}}class ErrorWithCode extends Error{constructor(t,e){super(e||""+t),this.code=t}}function g(t,e){return new ErrorWithCode(t,e)}const b=/^(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})(\d+)(?:.\d+)?$/;async function T(t){try{return await t}catch(t){if(t instanceof ErrorWithCode&&(500==t.code||502==t.code))return[502,t.message];throw t}}async function E(t){let e,s;do{e=await t.next(),e.done&&!e.value||(s=e.value)}while(!e.done);return s}exports.ErrorWithCode=ErrorWithCode,exports.FTP=FTP,exports.default=FTP;
//# sourceMappingURL=connection.js.map
