#!/usr/bin/env node
var e=require("url"),t=require("events"),s=require("net"),r=require("string_decoder"),i=require("tls"),n=require("zlib"),o=require("stream"),a=require("readline");function c(e){return e&&"object"==typeof e&&"default"in e?e:{default:e}}function h(e){if(e&&e.__esModule)return e;var t=Object.create(null);return e&&Object.keys(e).forEach((s=>{if("default"!==s){var r=Object.getOwnPropertyDescriptor(e,s);Object.defineProperty(t,s,r.get?r:{enumerable:!0,get:()=>e[s]})}})),t.default=e,Object.freeze(t)}var d=c(t),l=h(s),u=h(i),p=c(n);function f(e){return this instanceof f?(this.v=e,this):new f(e)}function w(e,t,s){if(!Symbol.asyncIterator)throw new TypeError("Symbol.asyncIterator is not defined.");var r,i=s.apply(e,t||[]),n=[];return r={},o("next"),o("throw"),o("return"),r[Symbol.asyncIterator]=function(){return this},r;function o(e){i[e]&&(r[e]=t=>new Promise(((s,r)=>{n.push([e,t,s,r])>1||a(e,t)})))}function a(e,t){try{(s=i[e](t)).value instanceof f?Promise.resolve(s.value.v).then(c,h):d(n[0][2],s)}catch(e){d(n[0][3],e)}var s}function c(e){a("next",e)}function h(e){a("throw",e)}function d(e,t){e(t),n.shift(),n.length&&a(n[0][0],n[0][1])}}function m(e){if(!Symbol.asyncIterator)throw new TypeError("Symbol.asyncIterator is not defined.");var t,s=e[Symbol.asyncIterator];return s?s.call(e):(e=function(e){var t="function"==typeof Symbol&&Symbol.iterator,s=t&&e[t],r=0;if(s)return s.call(e);if(e&&"number"==typeof e.length)return{next(){return e&&r>=e.length&&(e=void 0),{value:e&&e[r++],done:!e}}};throw new TypeError(t?"Object is not iterable.":"Symbol.iterator is not defined.")}(e),t={},r("next"),r("throw"),r("return"),t[Symbol.asyncIterator]=function(){return this},t);function r(s){t[s]=e[s]&&(t=>new Promise(((r,i)=>{((e,t,s,r)=>{Promise.resolve(r).then((t=>{e({value:t,done:s})}),t)})(r,i,(t=e[s](t)).done,t.value)})))}}const _=/^total/,g=/(?:^|\r?\n)(\d{3}) [^\r\n]*\r?\n/,y=/\r?\n/g,v=/-/g,b=new Map([["jan",1],["feb",2],["mar",3],["apr",4],["may",5],["jun",6],["jul",7],["aug",8],["sep",9],["oct",10],["nov",11],["dec",12]]);class Parser extends o.Writable{constructor(e){super(),this._buffer="",this._debug=e.debug}static parseFeat(e){const t=e.split(y);t.shift(),t.pop();for(let e=0,s=t.length;e<s;++e)t[e]=t[e].trim();return t}async _write(e,t,s){const r=this._debug;let i;for(r&&r("[parser] write()"),this._buffer+=e.toString("binary"),r&&r("[parser] buffer: "+this._buffer);i=g.exec(this._buffer);){const e=this._buffer.substring(i.index+i[0].length);e.length&&(this._buffer=this._buffer.substring(0,i.index+i[0].length)),r&&r("[parser] < "+this._buffer);const t=parseInt(i[1],10);let s="(^|\\r?\\n)";s+=i[1],s+="(?: |\\-)";const n=new RegExp(s,"g"),o=this._buffer.replace(n,"$1").trim();this._buffer=e,r&&r("[parser] Response: code="+t+", buffer="+o),await this.emit("response",t,o)}s()}}const S=/^([-ld])((?:[-r][-w][-xstT]){3})(\+)?\s+(\d+)\s+(\S+)\s+(\S+)\s+(\d+)\s+(?:(?:(\w{3})\s+(\d{1,2})\s+(\d{1,2}):(\d{2}))|(?:(\w{3})\s+(\d{1,2})\s+(\d{4})))\s+(.+)$/,T=/^(\d{2})(?:-|\/)(\d{2})(?:-|\/)(\d{2,4})\s+(\d{2}):(\d{2})\s{0,1}([AaMmPp]{1,2})\s+(?:(\d+)|(<DIR>))\s+(.+)$/;function P(e){return(4&e?"r":"-")+(2&e?"w":"-")+(1&e?"x":"-")}function E(e){const t=(e=>{const t={name:""};for(;e&&!e.startsWith(" ");){const s=e.indexOf("=");if(-1==s)return"unexpected entry fact, no equals";const r=e.indexOf(";",s);if(-1==r)return"unexpected entry fact, no semicolon";t[e.substring(0,s).toLowerCase().replace(/-./g,(e=>e.substring(1).toUpperCase())).replace(/^.*?\./,(e=>e.toUpperCase()))]=e.substring(s+1,r),e=e.substring(r+1)}return e&&e.startsWith(" ")?(t.name=e.substring(1),t):"unexpected entry char, expected space followed by filename"})(e);if("string"==typeof t)return e;const s={acl:void 0,date:void 0,group:t["UNIX.groupname"]||t["UNIX.group"],name:t.name,owner:t["UNIX.ownername"]||t["UNIX.owner"],rights:void 0,size:t.size?parseInt(t.size,10):-1,sticky:!1,target:void 0,type:"dir"==t.type||"cdir"==t.type||"pdir"==t.type?"d":"-"};if(t.modify){const e=/^(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})(\.\d+)?$/.exec(t.modify);if(e){let t=0;if(e[7]){const s=parseInt(e[7].substring(1)),r=4-e[7].length;t=0==r?s:r>0?s*Math.pow(10,r):s/Math.pow(10,-r)}s.date=new Date(Date.UTC(parseInt(e[1]),parseInt(e[2])-1,parseInt(e[3]),parseInt(e[4]),parseInt(e[5]),parseInt(e[6]),t))}}if(t["UNIX.mode"]&&4==t["UNIX.mode"].length){const e=parseInt(t["UNIX.mode"],8);s.rights={user:P(e>>6),group:P(e>>3),other:P(e)}}else if(t.perm){let e=0;for(let s=0;s<t.perm.length;s++)switch(t.perm[s]){case"a":case"c":case"m":case"p":case"w":e|=2;break;case"r":e|=4;break;case"e":case"l":e|=1}s.rights={user:P(e),group:"---",other:"---"}}return Object.assign(s,{mlsx:t})}function k(e){let t;if(t=(e=>{const t=e.match(S);return t?{acl:t[3],date1:t[9],date2:t[13],group:t[6],hour:t[10],inodes:t[4],minute:t[11],month1:t[8],month2:t[12],name:t[15],owner:t[5],permission:t[2],size:t[7],type:t[1],year:t[14]}:null})(e)){let e,s;if("l"===t.type){const r=t.name.indexOf(" -> ");e=t.name.substring(0,r),s=t.name.substring(r+4)}else e=t.name;const r={acl:"+"===t.acl,date:void 0,group:t.group,name:e,owner:t.owner,rights:{group:t.permission.substring(3,6).replace(v,""),other:t.permission.substring(6,9).replace(v,""),user:t.permission.substring(0,3).replace(v,"")},size:parseInt(t.size,10),sticky:!1,target:s,type:t.type},i=r.rights&&r.rights.other.slice(-1);if(r.rights&&("t"===i?(r.rights.other=r.rights.other.slice(0,-1)+"x",r.sticky=!0):"T"===i&&(r.rights.other=r.rights.other.slice(0,-1),r.sticky=!0)),void 0!==t.month1&&void 0!==t.date1&&void 0!==t.hour&&void 0!==t.minute){const e=b.get(t.month1.toLowerCase()),s=parseInt(t.date1,10),i=(new Date).getFullYear(),n=parseInt(t.hour,10),o=parseInt(t.minute,10);let a=e.toString(),c=s.toString(),h=n.toString(),d=o.toString();e<10&&(a="0"+e),s<10&&(c="0"+s),n<10&&(h="0"+n),o<10&&(d="0"+o),r.date=new Date(i+"-"+a+"-"+c+"T"+h+":"+d),r.date.getTime()-Date.now()>1008e5&&(r.date=new Date(i-1+"-"+e+"-"+s+"T"+n+":"+o)),Date.now()-r.date.getTime()>160704e5&&(r.date=new Date(i+1+"-"+e+"-"+s+"T"+n+":"+o))}else if(void 0!==t.month2&&void 0!==t.date2&&void 0!==t.year){const e=b.get(t.month2.toLowerCase()),s=parseInt(t.date2,10),i=parseInt(t.year,10);let n=e.toString(),o=s.toString();e<10&&(n="0"+e),s<10&&(o="0"+s),r.date=new Date(i+"-"+n+"-"+o+"T00:00")}return r}if(t=(e=>{const t=e.match(T);return t?{ampm:t[6],date:t[2],hour:t[4],isdir:t[8],minute:t[5],month:t[1],name:t[9],size:t[7],year:t[3]}:null})(e)){const e=parseInt(t.month,10),s=parseInt(t.date,10);let r=parseInt(t.year,10),i=parseInt(t.hour,10);const n=parseInt(t.minute,10);return r+=r<70?2e3:1900,"p"===t.ampm[0].toLowerCase()&&i<12?i+=12:"a"===t.ampm[0].toLowerCase()&&12===i&&(i=0),{date:new Date(r,e-1,s,i,n),name:t.name,size:t.isdir?0:parseInt(t.size,10),type:t.isdir?"d":"-"}}return _.test(e)?null:e}const I=/(\d+),(\d+),(\d+),(\d+),([-\d]+),([-\d]+)/,R=/\((.)\1\1(\d+)\1\)/,O=/\r?\n/g,A=/"(.+)"(?: |$)/,x=/^([^ ]+)(?: |$)/,q=Buffer.from("NOOP\r\n");class FTP extends d.default{constructor(){super(...arguments),this.options={secure:!1},this.connected=!1,this._pasvReady=Promise.resolve(),this._queue=[],this._ending=!1,this._detectedSupport={},this._send=function(e,t){return w(this,arguments,(function*(){let s=null,r=null,i=null,n=null;if(this._keepalive&&(clearTimeout(this._keepalive),this._keepalive=void 0),void 0!==e){const o=(e,t,o)=>{e?n?n(e):r=e:i?i([o,t]):s=[o,t]};t?this._queue.unshift({cmd:e,cb:o}):this._queue.push({cmd:e,cb:o})}const o=this._queue.length;!this._curReq&&o&&this._socket&&this._socket.readable?(this._curReq=this._queue.shift(),"ABOR"===this._curReq.cmd&&this._pasvSocket&&(this._pasvSocket.aborting=!0),this._debug&&this._debug("[connection] > "+this._curReq.cmd),this._socket.write(this._curReq.cmd+"\r\n")):this._curReq||o||!this._ending||this._reset();let a=!1;for(;!a;){const e=new Promise(((e,t)=>{i=e,n=t,s?i(s):null!==r&&n(r)})),t=yield f(e);i=null,n=null,s=null,r=null,a=void 0===this._curReq,yield yield f(t)}}))}}static async connect(e={}){const t=new FTP;try{return await t.connect(e)}catch(e){throw t.logout().catch((e=>e)),e}}get feat(){return this._feat}connect(e={}){return new Promise(((t,s)=>{let r=!0;this.connected=!1,this.options.host=e.host||"localhost",this.options.port=e.port||21,this.options.user=e.user||"anonymous",this.options.password=e.password||""===e.password?e.password:"anonymous@",this.options.secure=e.secure||!1,this.options.secureOptions=e.secureOptions,this.options.connTimeout=e.connTimeout||1e4,this.options.dataTimeout=e.dataTimeout||e.pasvTimeout||1e4,this.options.aliveTimeout=e.keepalive||1e4,this.options.portAddress=e.portAddress,this.options.portRange=e.portRange,this.options.overrideFeats=e.overrideFeats,"function"==typeof e.debug&&(this._debug=e.debug);const i={},n=this._debug;let o=new l.Socket;if(o.setTimeout(0),o.setKeepAlive(!0),this._parser=new Parser({debug:n}),this._parser.on("response",((e,t)=>{const i=e/100|0;if(4===i||5===i)if(this._curReq){const s=this._curReq;this._curReq=void 0,s.cb(D(e,t),void 0,e),L(this._send())}else{const i=D(e,t);this.emit("error",i),r&&(s(i),r=!1)}else if(this._curReq){const s=this._curReq;1!==i?(this._curReq=void 0,s.cb(void 0,t,e),L(this._send())):s.cb(void 0,t,e)}a.cb()})),this.options.secure){i.host=this.options.host;const e=this.options.secureOptions;e&&Object.assign(i,e),i.socket=o,this.options.secureOptions=i}const a={cb:()=>{this._keepalive&&clearTimeout(this._keepalive),this._keepalive=setTimeout(c,this.options.aliveTimeout)},cmd:"NOOP"},c=()=>{this._socket&&this._socket.writable?this._curReq||0!==this._queue.length?a.cb():(this._curReq=a,n&&n("[connection] > NOOP"),this._socket.write(q)):this._keepalive&&(clearTimeout(this._keepalive),this._keepalive=void 0)},h=()=>{let e;clearTimeout(m),this._keepalive&&(clearTimeout(this._keepalive),this._keepalive=void 0),this.connected=!0,this._socket=o;const t=([s,n])=>{if("AUTH TLS"===e&&234!==s&&!0!==this.options.secure||"AUTH SSL"===e&&334!==s||"PBSZ"===e&&200!==s||"PROT"===e&&200!==s){const e=new ErrorWithCode(s,"Unable to secure connection(s)");throw this.emit("error",e),this._socket&&this._socket.end(),e}if(e){if("USER"===e){if(230!==s){if(!this.options.password&&""!==this.options.password){const e=D(s,"Password required");throw this.emit("error",e),this._socket&&this._socket.end(),e}return e="PASS",L(this._send("PASS "+this.options.password,!0)).then(t)}return e="PASS",t([s,n])}if("PASS"===e)return e="FEAT",L(this._send(e,!0)).then((e=>(e[1]&&(this._feat=Parser.parseFeat(e[1])),e)),(e=>{if(500!==e.code)throw e;return[e.code,e.message]})).then((e=>{this._feat||(this._feat=[]);const t=this.options.overrideFeats;if(t)for(const e of Object.keys(t)){const s=t[e];if("boolean"!=typeof s)if("string"!=typeof s);else{const t=this._feat.findIndex((t=>t==e||t.startsWith(e+" ")));if(-1==t){this._feat.push(e+" "+s);continue}this._feat[t]=e+" "+s}else{const t=this._feat.findIndex((t=>t==e||t.startsWith(e+" ")));if(-1==t&&s){this._feat.push(e);continue}if(-1!=t&&!s){this._feat.splice(t,1);continue}}}return e})).then(t);if("FEAT"===e)return e="TYPE",L(this._send("TYPE I",!0)).then(t);if("TYPE"===e)return this.emit("ready"),r=!1,this;if("PBSZ"===e)return e="PROT",L(this._send("PROT P",!0)).then(t);if("PROT"===e)return e="USER",L(this._send("USER "+this.options.user,!0)).then(t);if("AUTH"===e.substring(0,4))return"AUTH TLS"===e&&234!==s?(e="AUTH SSL",L(this._send(e,!0)).then(t)):("AUTH TLS"===e?this._secstate="upgraded-tls":"AUTH SSL"===e&&(this._secstate="upgraded-ssl"),o.removeAllListeners("data"),o.removeAllListeners("error"),this._curReq=void 0,i.socket=this._socket,i.session=void 0,new Promise((e=>{o=u.connect(i,(()=>e(h()))),o.setEncoding("binary"),o.on("data",d),o.once("end",f),o.on("error",p)})));throw new Error("No matched command: "+JSON.stringify(e))}return this.emit("greeting",n),this.options.secure&&"implicit"!==this.options.secure?(e="AUTH TLS",L(this._send(e,!0)).then(t)):(e="USER",L(this._send("USER "+this.options.user,!0)).then(t))},s=e=>{throw o.destroyed&&o.end(),e};if(this._secstate)return"upgraded-tls"===this._secstate&&!0===this.options.secure?(e="PBSZ",L(this._send("PBSZ 0",!0)).then(t).catch(s)):(e="USER",L(this._send("USER "+this.options.user,!0)).then(t).catch(s));{let e,r=null,i=null,n=null;const o=new Promise(((t,s)=>{r=t,i=s,n?t(n):void 0!==e&&s(e)}));return this._curReq={cb(s,o,a){s?i?i(s):e=s:r?r(t([a,o])):n=t([a,o])},cmd:""},o.catch(s)}};"implicit"===this.options.secure?this._socket=u.connect(i,(()=>h().then(t,s))):(o.once("connect",(()=>h().then(t,s))),this._socket=o);const d=e=>{n&&n("[connection] < "+e.toString("binary")),this._parser.write(e)};o.on("data",d);const p=e=>{clearTimeout(m),this._keepalive&&(clearTimeout(this._keepalive),this._keepalive=void 0),r?(s(e),r=!1,this._socket&&!this._socket.destroyed&&this._socket.end()):this.listenerCount("error")&&this.emit("error",e)};o.on("error",p);const f=()=>{w||(w=!0,clearTimeout(m),this._reset()),this.emit("end"),r&&(s("End before ready"),r=!1)};o.once("end",f),o.once("close",(e=>{w||(w=!0,clearTimeout(m),this._reset()),this.emit("close",e),r&&(s("Close before ready"),r=!1)}));let w=!1;const m=setTimeout((()=>{!this.listenerCount("error")&&r||this.emit("error",new Error("Timeout while connecting to server")),this._socket&&this._socket.destroy(),this._reset(),r&&(s(new Error("Timeout while connecting to server")),r=!1)}),this.options.connTimeout);try{this._socket.connect(this.options.port,this.options.host)}catch(e){s(e)}}))}end(){this._queue.length||this._curReq?this._ending=!0:this._reset()}destroy(){this._reset()}ascii(){return L(this._send("TYPE A"))}binary(){return L(this._send("TYPE I"))}abort(e=!0){return L(this._send("ABOR",Boolean(e)))}cwd(e,t){return L(this._send("CWD "+e,t)).then((([e,t])=>{const s=t&&A.exec(t);return s?s[1]:void 0}))}delete(e){return L(this._send("DELE "+e))}site(e){return L(this._send("SITE "+e))}status(){return L(this._send("STAT")).then((([e,t])=>t))}rename(e,t){return L(this._send("RNFR "+e)).then((()=>L(this._send("RNTO "+t,!0))))}logout(){return L(this._send("QUIT"))}async listSafe(e,t){if("string"!=typeof e)return"boolean"==typeof e?this.list(e):this.list();{const s=await this.pwd();await this.cwd(e);try{return this.list(t||!1)}finally{s&&await this.cwd(s)}}}async fileInfo(e){const t=this._feat||[];let s;if(!1!==this._detectedSupport.mlst)for(const e of t){if(!e.startsWith("MLST "))continue;const t=e.substring(5).split(";");t.length&&!t[t.length-1]&&t.pop(),s=t;break}if(!s){const t=await this.list(e,!1);let s=null;if(1==t.length&&"string"!=typeof t[0])s=t[0];else for(const r of t)"string"==typeof r||"."!=r.name&&r.name!=e||s&&"."==s.name||(s=r);return s}const[r,i]=await C(L(this._send("MLST "+e,!1)));if(502==r)return this._detectedSupport.mlst=!1,this.fileInfo(e);const n=E(i||"");if("string"==typeof n)throw new Error(n);return n}async list(e,t){let s;const i=this._feat||[];let n;if(!1!==this._detectedSupport.mlst)for(const e of i){if(!e.startsWith("MLST "))continue;const t=e.substring(5).split(";");t.length&&!t[t.length-1]&&t.pop(),n=t;break}return"boolean"==typeof e&&(t=e,e=void 0),s=e&&n?"MLSD "+e:e?"LIST "+e:n?"MLSD":"LIST",this._pasv((async i=>{if(this._queue[0]&&"ABOR"===this._queue[0].cmd){const e=new Error("Aborted");throw e.code="aborted",e}let n,o=!1,a="";const c=new r.StringDecoder("utf8");let h;t?(h=p.default.createInflate(),i.pipe(h)):h=i;const d=()=>{c&&(a+=c.end()),o=!0,v()};h.on("data",(e=>{a+="string"==typeof e?c.write(Buffer.from(e)):c.write(e)})),h.once("error",(e=>{i.aborting||(n=e)})),h.once("end",d),h.once("close",d);let l,u=null,f=null,w=null;const _=new Promise(((e,t)=>{u=e,f=t,w?e(w):void 0!==l&&t(l)}));let g=0;const y=async()=>{var t,r;const i=[];try{for(var n,o=m(this._send(s,!0));!(n=await o.next()).done;){const[e]=n.value;i.push(e),1==++g&&226===e&&(g=2)}}catch(e){t={error:e}}finally{try{n&&!n.done&&(r=o.return)&&await r.call(o)}finally{if(t)throw t.error}}if("string"==typeof e&&s.startsWith("MLSD ")&&501==i[i.length-1]){const t=await this.fileInfo(e);return{a:t?[t]:[]}}if(2===g)return v();throw new Error("Expected 2 replies for list, count: "+g+", codes: "+i.join(", "))},v=()=>{if(o&&2===g){if(g=3,n){const e=new Error("Unexpected data connection error: "+n);throw f?f(e):l=e,e}if(i.aborting){const e=new Error("Aborted");throw e.code="aborted",f?f(e):l=e,e}const e=a.split(O);this._debug&&this._debug("Listing entries: "+JSON.stringify(e)),e.pop();const t=[];if(s.startsWith("MLSD"))for(let s=0,r=e.length;s<r;++s){const r=E(e[s]);"string"!=typeof r?t.push(r):this._debug&&this._debug("Skipped entry listing: "+r+": "+JSON.stringify(e[s]))}else for(let s=0,r=e.length;s<r;++s){const r=k(e[s]);null!==r?t.push(r):this._debug&&this._debug("Skipped entry listing: "+JSON.stringify(e[s]))}const r={a:t};return u?u(r):w=r,Promise.resolve(r)}return _};if(!t)return y();await L(this._send("MODE Z",!0));try{return await y()}finally{await L(this._send("MODE S",!0))}})).then((e=>e.a))}get(e,t){return this._pasv((async s=>{if(this._queue[0]&&"ABOR"===this._queue[0].cmd){const e=new Error("Aborted");throw e.code="aborted",e}let r,i=!1,n=!1,o=s;if(t){o=p.default.createInflate(),s.pipe(o);const e=s.emit;s.emit=(t,...i)=>"error"===t?(r||(r=new Error(i.join(", "))),!0):(i.unshift(t),e.apply(s,i),!0)}let a,c=null,h=null,d=!1;const l=new Promise(((e,t)=>{c=e,h=t,d?e():void 0!==a&&t(a)})),u=o.emit;o.emit=(e,...t)=>"error"===e?(r||(r=new Error(t.join(", "))),h?h(r):a=r||null,!0):"end"===e||"close"===e?(n||(n=!0),c?c():d=!0,!0):(t.unshift(e),this._debug&&this._debug("Get source emit: "+JSON.stringify(t)),u.apply(o,t),!0),s.pause();const f=()=>new Promise((async(t,s)=>{try{t([L(await(async()=>{const t=this._send("RETR "+e,!0);for(;;){const e=await t.next();if(e.done)throw new Error("Expexted result RETR");const[s]=e.value;if(this._debug&&this._debug("Get code: "+s),150===s||125===s)return i=!0,t}})()).then((()=>l)),o])}catch(e){s(e)}}));if(t){await L(this._send("MODE Z",!0));try{return await f()}finally{await L(this._send("MODE S",!0));const e=()=>{n?(u.call(o,"end"),u.call(o,"close")):i&&(u.call(o,"error",r),u.call(o,"close",!0))};l.then(e,e)}}else try{return await f()}finally{const e=()=>{n?(u.call(o,"end"),u.call(o,"close")):i&&(u.call(o,"error",r),u.call(o,"close",!0))};l.then(e,e)}}))}put(e,t,s){return this._store("STOR "+t,e,s||!1)}append(e,t,s){return this._store("APPE "+t,e,s||!1)}async pwd(){if(!1!==this._detectedSupport.pwd){const[e,t]=await C(L(this._send("PWD")));if(502!=e)return t&&(A.exec(t)||[])[1]}return this._detectedSupport.pwd=!1,this.cwd(".",!0)}async cdup(){if(!1!==this._detectedSupport.cdup){const[e]=await C(L(this._send("CDUP")));if(502!=e)return}return this._detectedSupport.cdup=!1,this.cwd("..",!0)}async mkdir(e,t){if(!t)return void await L(this._send("MKD "+e));const s=await this.pwd(),r="/"===e[0],i=s;r&&(e=e.substring(1)),"/"===e[e.length-1]&&(e=e.substring(0,e.length-1));const n=e.split("/"),o=n.length,a=async()=>{var e,t;let s=-1,r=!0;if(++s!==o){if(!r)return await L(this._send("MKD "+n[s],!0)),await L(this._send("CWD "+n[s],!0)),a();try{for(var i,c=m(this._send("CWD "+n[s],!0));!(i=await c.next()).done;){const[e]=i.value;return 550===e&&(r=!1,--s),a()}}catch(t){e={error:t}}finally{try{i&&!i.done&&(t=c.return)&&await t.call(c)}finally{if(e)throw e.error}}}};try{r?(await L(this._send("CWD /",!0)),await a()):await a()}finally{await L(this._send("CWD "+i,!0))}}rmdir(e,t){return t?this.list(e).then((async t=>{for(const s of t){if("string"==typeof s)throw new Error("Cannot remove when listing is string");let t=null;if(t="/"===s.name[0]?s.name:"/"===e[e.length-1]?e+s.name:e+"/"+s.name,"d"===s.type){if("."===s.name||".."===s.name)continue;await this.rmdir(t,!0)}else await this.delete(t)}return L(this._send("RMD "+e))})):L(this._send("RMD "+e))}async system(){const e=(await L(this._send("SYST")))[1];return e&&(x.exec(e)||[])[1]||""}async size(e){let t,s=502;return!1!==this._detectedSupport.size&&([s,t]=await C(L(this._send("SIZE "+e)))),502===s?(this._detectedSupport.size=!1,this.fileInfo(e).then((t=>{if(!t)throw new Error("Unable to get info for path "+JSON.stringify(e));if("d"==t.type)throw new Error("Can not get the size of a directory");if(-1!=t.size)return t.size;throw new Error("File not found")}))):t?parseInt(t,10):-1}async lastMod(e){let t,s=502;if(!1!==this._detectedSupport.mdtm&&([s,t]=await C(L(this._send("MDTM "+e)))),502===s)return this._detectedSupport.mdtm=!1,this.fileInfo(e).then((t=>{if(t&&t.date)return t.date;throw new Error("No modification time available for file "+JSON.stringify(e))}));if(s>=400)throw Object.assign(new Error("Error for modification time ("+s+"): "+t),{code:s});const r=(e=>{const t=e&&e.match(U);if(t)return{date:t[3],hour:t[4],minute:t[5],month:t[2],second:t[6],year:t[1]}})(t);if(!r)throw new Error("Invalid date/time format from server");return new Date(r.year+"-"+r.month+"-"+r.date+"T"+r.hour+":"+r.minute+":"+r.second)}restart(e){return L(this._send("REST "+e))}localPort(e,t){const s=l.isIP(e);if(0==s)throw new Error("Invalid IP: "+e);return[e=4==s?"0.0.0.0":"::",t||"5000-8000"]}async _pasv(e){let t,s,r=!0;const i=()=>{var e,t;const s=this._feat||[];return 0!=s.length&&!s.includes("EPSV")&&[void 0,"IPv4"].includes(null===(e=this._socket)||void 0===e?void 0:e.remoteFamily)||!1===this._detectedSupport.epsv?(0==s.length||s.includes("PASV"))&&!1!==this._detectedSupport.pasv&&[void 0,"IPv4"].includes(null===(t=this._socket)||void 0===t?void 0:t.remoteFamily)?"PASV":"":"EPSV"};let n="";const o=async([e,i])=>{if(this._curReq=void 0,!r||n&&"PASV"!=n){if(r){const e=i&&R.exec(i);if(!e)throw new Error("Unable to parse EPSV server response");t=this._socket.remoteAddress,s=parseInt(e[2],10),r=!1}}else{const e=i&&I.exec(i);if(!e)throw new Error("Unable to parse PASV server response");t=e[1],t+=".",t+=e[2],t+=".",t+=e[3],t+=".",t+=e[4],s=parseInt(e[5],10)<<8|parseInt(e[6],10),r=!1}const a=await this._pasvConnect(t,s).catch((e=>this._socket&&t!==this._socket.remoteAddress?(t=this._socket.remoteAddress,o([0,""])):L(this._send("ABOR",!0)).then((()=>{throw L(this._send()),e}))));return L(this._send()),a},a=async e=>{const t=await this._portConnect(e).catch((e=>L(this._send("ABOR",!0)).then((()=>{throw L(this._send()),e}))));return L(this._send()),t},c=async()=>{const t=this.options.portAddress;if(n=i(),n||!t)return L(this._send(n||"PASV")).then((async t=>{const s=await o(t),r=await e(s);return Array.isArray(r)?[r[0].then((()=>s.destroy()),(()=>s.destroy())),r[1]]:(s.destroy(),[Promise.resolve(),r])}),(e=>{if(500!=e.code&&502!=e.code||!n||("PASV"==n?this._detectedSupport.pasv=!1:"EPSV"==n&&(this._detectedSupport.epsv=!1)),!t&&!n)throw e;return c()}));{const s=l.isIP(t);if(4!=s&&6!=s)throw new Error("Invalid `portAddress`, must be IPv4 or IPv6: "+JSON.stringify(t));const[r,i]=await this.localPort(t,this.options.portRange),n=l.isIP(r);if(4!=n&&6!=n)throw new Error("Invalid `bindIp`, must be IPv4 or IPv6: "+JSON.stringify(r));if(!(4==n||this._feat&&this._feat.includes("EPRT")&&!1!==this._detectedSupport.eprt))throw new Error("Only IPv4 may be used for `bindIp` when connecting to servers without `EPRT` support");const o=await((e,t)=>new Promise(((s,r)=>{if(e){const i=l.createServer();let[n,o]="string"==typeof e?e.split("-",2).map((e=>e?parseInt(e,10):0)):[e,e];n||(n=1),(!o||o>65535)&&(o=65535),i.maxConnections=1;const a=()=>{n<o?(n++,i.listen(n,t)):r(new Error("Unable to find available port"))};i.on("error",a),i.on("listening",(()=>{i.removeListener("error",a),s(i)})),i.listen(n,t)}else r(new Error("Invalid `portRange`"))})))(i||"5000-8000",r),c=a(o),h=o.address(),d="string"!=typeof h?h.port:0;let u;if(4==n){const e=d>>8,s=255&d;u="PORT "+t.replace(/\./g,",")+","+e+","+s}else u="EPRT |2|"+t+"|"+d+"|";await L(this._send(u));const p=await c,f=await e(p).catch((e=>{throw e}));return Array.isArray(f)?[f[0].then((()=>p.destroy()),(()=>p.destroy())),f[1]]:(p.destroy(),[Promise.resolve(),f])}},h=this._pasvReady.then(c);return this._pasvReady=h.then((e=>e[0]),(()=>{})),h.then((e=>e[1]))}_portConnect(e){return new Promise(((t,s)=>{let r=null,i=!1;const n=setTimeout((()=>{i=!0,e.close(),s(new Error("Timed out while making data connection"))}),this.options.dataTimeout);e.on("connection",(o=>{this._pasvSocket=o,clearTimeout(n),this._debug&&this._debug("[connection] PORT socket connected"),o.once("error",(e=>{r=e,s(r)})),o.once("close",(()=>{if(!this._pasvSocket&&!i){let e="Unable to make data connection";r&&(e+="( "+r+")",r=null),s(new Error(e))}this._pasvSocket=void 0,e.close()})),t(o)})),e.on("error",s),e.on("close",(()=>{if(!this._pasvSocket&&!i){let e="Unable to make data connection";r&&(e+="( "+r+")",r=null),s(new Error(e))}this._pasvSocket=void 0}))}))}_pasvConnect(e,t){return new Promise(((s,r)=>{let i=new l.Socket,n=null,o=!1;const a=setTimeout((()=>{o=!0,i.destroy(),r(new Error("Timed out while making data connection"))}),this.options.dataTimeout);i.setTimeout(0),i.once("connect",(()=>{this._debug&&this._debug("[connection] PASV socket connected"),!0===this.options.secure&&(this.options.secureOptions=this.options.secureOptions||{},this.options.secureOptions.socket=i,this.options.secureOptions.session=this._socket.getSession(),i=u.connect(this.options.secureOptions),i.setTimeout(0)),clearTimeout(a),this._pasvSocket=i,s(i)})),i.once("error",(e=>{n=e,r(n)})),i.once("end",(()=>{clearTimeout(a)})),i.once("close",(()=>{if(clearTimeout(a),!this._pasvSocket&&!o){let e="Unable to make data connection";n&&(e+="( "+n+")",n=null),r(new Error(e))}this._pasvSocket=void 0})),i.connect(t,e)}))}_store(e,t,s){return Buffer.isBuffer(t)||"string"==typeof t||void 0===t.pause||t.pause(),this._pasv((async r=>{if(this._queue[0]&&"ABOR"===this._queue[0].cmd){const e=new Error("Aborted");throw e.code="aborted",e}let i=null;r.once("error",(e=>{i=e}));const n=async s=>{var r,i;try{for(var n,o=m(this._send(e,!0));!(n=await o.next()).done;){const[e]=n.value;150!==e&&125!==e||(Buffer.isBuffer(t)?(s.write(t),s.end()):"string"==typeof t?await Promise.resolve().then((()=>h(require("fs")))).then((e=>{e.stat(t,(r=>{r?s.end():e.createReadStream(t).pipe(s)}))})):(t.pipe(s),t.resume()))}}catch(e){r={error:e}}finally{try{n&&!n.done&&(i=o.return)&&await i.call(o)}finally{if(r)throw r.error}}};try{if(!s)return n(r);{await L(this._send("MODE Z",!0));const e=p.default.createDeflate({level:8});try{return e.pipe(r),n(e)}finally{e.end(),await L(this._send("MODE S",!0))}}}catch(e){throw e||i}}))}_reset(){this._pasvSock&&this._pasvSock.writable&&this._pasvSock.end(),this._socket&&this._socket.writable&&this._socket.end(),this._socket=void 0,this._pasvSock=void 0,this._feat=void 0,this._curReq=void 0,this._secstate=void 0,this._keepalive&&(clearTimeout(this._keepalive),this._keepalive=void 0),this._queue=[],this._ending=!1,this._parser=void 0,this.options.host=this.options.port=this.options.user=this.options.password=this.options.secure=this.options.connTimeout=this.options.dataTimeout=this.options.keepalive=this._debug=void 0,this.connected=!1}}class ErrorWithCode extends Error{constructor(e,t){super(t||""+e),this.code=e}}function D(e,t){return new ErrorWithCode(e,t)}const U=/^(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})(\d+)(?:.\d+)?$/;async function C(e){try{return await e}catch(e){if(e instanceof ErrorWithCode&&(500==e.code||502==e.code))return[502,e.message];throw e}}async function L(e){let t,s;do{t=await e.next(),t.done&&!t.value||(s=t.value)}while(!t.done);return s}const N=["list","get","put","append","exit","rename","delete","abort","cwd","status"],M=Symbol("Mute"),W=((F=process.stdout)[M]=!1,new Proxy(F,{get:(e,t)=>"mute"===t?e[M]:"_write"===t?(t,s,r)=>{const i=e[M];!1===i?e._write(t,s,r):!0===i||""===i||"object"==typeof t&&!Buffer.isBuffer(t)?r&&r():e._write(i.repeat(t.length),s||"uft8",r)}:e[t],set:(e,t,s)=>"mute"===t?(e[M]=s,!0):(e[t]=s,!0),has:(e,t)=>"mute"===t||Object.prototype.hasOwnProperty.call(e,t)}));var F;const B=a.createInterface({completer(e,t){if(z.state){const s=N.filter((t=>t.startsWith(e)));t(null,[s.length?s:N,e])}else t(null,[[],e])},input:process.stdin,output:W,prompt:"ftps-ts> "}),j=process.argv.slice(2),z={debug:!1,enteredPassword:void 0,secure:void 0,state:0,portAddress:void 0,portRange:void 0};function V(e){e("Usage:    ftp-ts [--verbose] [--implicit | --explicit | --secure-control] [--port-addr=PORT_ADDR] [--port-range=PORT_RANGE] [--password] <CONNECTION> [+FEAT0, +FEAT1..] [.FEAT0, .FEAT1..]"),e(""),e("Flags:"),e("  -v --verbose         Print verbose protocol information."),e("     --explicit        The control connection is upgraded to SSL/TLS, the data channel is also encrypted."),e("     --implicit        The control connection is established using SSL/TLS, the data channel is not encrypted."),e("     --secure-control  Like `explicit` for the control channel, except the data channel is not encrypted."),e("     --port-addr=PA    The IP to use for PORT commands."),e("     --port-range=PR   The range of port numbers to choose from for PORT commands. Default: `5000-8000`."),e("  -p --password        Enter the password into the CLI prompt."),e(""),e("CONNECTION:"),e("  The URI to connect to."),e("  If the protocol is `ftps` the `explicit` mode will be used if no other has been specified."),e("  "),e("  Example: `ftps://localhost` for an anonymous login over TLS."),e("  Example: `ftp://localhost` for an anonymous login without encryption."),e("  Example: `ftps://usera@localhost` for a user login (combine with `-p` for password)."),e("  Example: `ftps://usera:passa@localhost` for a password login (not recommended, use `-p`).")}function J(){z.state=1,j[0]||(console.error("No connection string given."),console.error(),V(console.error),process.exit(1));const t=new e.URL(j[0]);j.splice(0,1);const s={host:t.hostname,password:void 0===z.enteredPassword?t.password:z.enteredPassword,port:t.port?parseInt(t.port,10):void 0,secure:void 0===z.secure?"ftps:"===t.protocol:z.secure,user:t.username,portAddress:z.portAddress,portRange:z.portRange};if(z.debug&&(s.debug=e=>{console.log("ftp-ts: [VERBOSE] ",e)}),j.length){s.overrideFeats={};for(const e of j)e.startsWith("+")?s.overrideFeats[e.substring(1).toUpperCase()]=!0:e.startsWith(".")&&(s.overrideFeats[e.substring(1).toUpperCase()]=!1)}return FTP.connect(s).then((e=>new Promise((t=>{B.on("SIGINT",(async()=>{try{await e.logout()}catch(e){B.write(e)}process.stdin.pause(),t()})),B.on("line",(async s=>{const r=s.split(" "),i=r[0];if("list"===i)try{console.dir(await e.list())}catch(e){B.write(e)}else if("get"===i){const t=r[1];if(void 0!==t){const s=r[2]?"true"===r[2]:void 0;try{await e.get(t,s)}catch(e){B.write(e)}}else B.write("Path are need to do get.")}else if("put"===i){const t=r[1],s=r[2];if(void 0!==t&&void 0!==s){const i=r[2]?"true"===r[2]:void 0;try{await e.put(t,s,i)}catch(e){B.write(e)}}else B.write("Path to file and destination are needed.")}else if("append"===i){const t=r[1],s=r[2];if(void 0!==t&&void 0!==s){const i=r[2]?"true"===r[2]:void 0;try{await e.append(t,s,i)}catch(e){B.write(e)}}else B.write("Path to file and destination are needed.")}else if("rename"===i){const t=r[1],s=r[2];if(void 0!==t&&void 0!==s)try{await e.rename(t,s)}catch(e){B.write(e)}else B.write("Old and new path are needed.")}else if("logout"===i||"exit"===i){try{await e.logout()}catch(e){B.write(e)}process.stdin.pause(),B.close(),t()}else if("delete"===i){const t=r[1];if(t)try{await e.delete(t),B.write("Deleted "+t)}catch(e){B.write(e)}else B.write("Path needed to delete a file.")}else if("cwd"===i){const t=r[1];if(t)try{B.write(await e.cwd(t)||t)}catch(e){B.write(e)}else B.write("Path needed to change directory.")}else if("abort"===i)try{await e.abort(),B.write("Aborted.")}catch(e){B.write(e)}else if("site"===i)if(r.length>1)try{await e.site(r.slice(1).join(" "))}catch(e){B.write(e)}else B.write("The SITE command needs a command to run.");else if("status"===i)try{B.write(await e.status())}catch(e){B.write(e)}}))}))),(e=>{e.message&&console.error(e.message),console.error(e),process.stdin.pause(),B.close()}))}for(let e=0;e<j.length;e++){const t=j[e];"-v"===t||"--verbose"===t?(j.splice(e--,1),z.debug=!0):t.startsWith("--port-range=")?(j.splice(e--,1),z.portRange=t.substring(13)):t.startsWith("--port-addr=")?(j.splice(e--,1),z.portAddress=t.substring(12)):"--implicit"===t?(j.splice(e--,1),z.secure="implicit"):"--secure-control"===t?(j.splice(e--,1),z.secure="control"):"--explicit"===t?(j.splice(e--,1),z.secure=!0):"--help"===t?(j.splice(e--,1),V(console.log),process.exit(0)):t&&"-"===t[0]&&"-p"!==t&&"--password"!==t&&(j.splice(e--,1),console.warn("Unrecognized argument: "+JSON.stringify(t)))}"-p"===j[0]||"--password"===j[0]?(j.splice(0,1),B.question("Password: ",(e=>{W.mute=!1,z.enteredPassword=e,W.write("\r\n"),J()})),W.mute="*"):J();
//# sourceMappingURL=bin.js.map
